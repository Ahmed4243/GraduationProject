<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="index.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        .main-content {
            margin-left: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            color: white;
        }

        .flex-container1 {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 20px;
            width: 100%;
        }

        .card {
            width: 150px;
            height: 200px;
            border-radius: 20px;
            background: #f5f5f5;
            border: 2px solid #c3c6ce;
            transition: 0.5s ease-out;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .project-title {
            font-family: 'Open Sans';
            font-weight: 500;
            font-size: 2em;
            cursor: text;
            padding: 8px 20px;
            border-radius: 8px;
            transition: all 0.2s ease;
            margin: 20px 0;
            border: 2px solid transparent;
            outline: none;
            min-width: 300px;
            text-align: center;
            background: transparent;
        }

        .project-title:hover {
            background: rgba(245, 245, 245, 0.6);
        }

        .project-title:focus {
            border: 2px solid #0d8bf1;
            background: white;
            box-shadow: 0 0 0 3px rgba(13, 139, 241, 0.15);
        }

        .project-title:empty::before {
            content: "Untitled Project";
            color: #888;
        }

        .project-title:focus:empty::before {
            content: "";
        }

        .card-details {
            padding: 5px;
            text-align: center;
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .card-details img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .card-button {
            width: 100%;
            padding: 8px 0;
            border: none;
            border-top: 1px solid #c3c6ce;
            background-color: #117c9f;
            cursor: pointer;
            font-size: 0.9em;
            font-family: 'Open Sans', sans-serif;
        }

        .block {
            margin-bottom: 20px;
            position: relative;
        }

        .block h1 {
            color: white;
            font-family: 'Open Sans', sans-serif;
            font-size: 1.4em;
            margin: 0;
            cursor: pointer;
        }

        .popup-menu {
            display: none;
            position: absolute;
            top: 0;
            left: 100%;
            background-color: white;
            box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 5px;
            padding: 20px;
            width: 230px;
            z-index: 1000;
            font-family: 'Open Sans', sans-serif;
            font-size: 1.4em;
            white-space: nowrap;
        }

        .popup-menu a {
            display: block;
            color: #34495e;
            text-decoration: none;
            margin: 10px 0;
            font-size: 1.1em;
        }

        .popup-menu a:hover {
            color: #00bfff;
        }

        .block:hover .popup-menu {
            display: block;
        }

        #dynamicTable {
            margin-bottom: 10px;
        }

        #dynamicTable th,
        #dynamicTable td {
            padding: 15px;
        }

        #dynamicTable td[contenteditable="true"]:focus {
            outline: 2px solid #f1960d;
        }

        #addColumn,
        #addRow,
        #removeLastRow {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }

        #addColumn {
            margin-left: 10px;
            height: 30px;
        }

        #addRow {
            margin-top: 10px;
        }

        #removeLastRow {
            background-color: #f44336;
        }

        #stats-sections-container {
            width: 100%;
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        #stats-sections-container > div {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 15px;
            width: auto;
            max-width: 90%;
        }

        #stats-sections-container label {
            font-family: 'Open Sans';
            font-size: 1em;
        }

        #stats-sections-container select {
            margin-right: 10px;
        }

        #stats-sections-container button {
            margin-left: 10px;
        }

        #stats-sections-container .remove-button {
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
            margin-left: auto;
        }

        #stats-sections-container .stats-output,
        #stats-sections-container .correlation-output {
            margin-top: 10px;
            font-family: 'Open Sans';
            font-size: 1em;
            width: 100%;
            padding-top: 5px;
            line-height: dialogs1.4;
        }

        #stats-sections-container .stats-output strong,
        #stats-sections-container .correlation-output strong {
            margin-right: 4px;
        }

        .context-menu {
            display: none;
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            padding: 5px 0;
            border-radius: 4px;
            min-width: 150px;
        }

        .context-menu div {
            padding: 8px 15px;
            cursor: pointer;
            font-family: 'Open Sans', sans-serif;
            font-size: 0.95em;
        }

        .context-menu div:hover {
            background-color: #f0f0f0;
        }

        .row-number {
            width: 40px !important;
            min-width: 40px !important;
            max-width: 40px !important;
            text-align: center;
            background-color: #f0f0f0 !important;
            user-select: none;
        }

        #dynamicTable th:first-child,
        #dynamicTable td:first-child {
            position: sticky;
            left: 0;
            z-index: 1;
        }

        .sidebar {
            height: 100%;
            width: 200px;
            background-color: #117c9f;
            box-shadow: 0 4px 25px 5px rgba(0, 0, 0, 0.5);
            position: fixed;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 1000;
        }

        .cleaning-dialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            min-width: 300px;
        }

        .cleaning-dialog label {
            display: block;
            margin: 10px 0 5px;
            font-family: 'Open Sans';
        }

        .cleaning-dialog select,
        .cleaning-dialog input[type="text"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
        }

        .cleaning-dialog-buttons {
            margin-top: 15px;
            text-align: right;
        }

        .cleaning-dialog-buttons button {
            margin-left: 10px;
            padding: 8px 15px;
            cursor: pointer;
        }

        .cancelButton {
            background-color: red;
        }

        .dialog-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        /* KNN Styles */
        .knn-section {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 15px;
            width: auto;
            max-width: 90%;
        }

        .knn-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .knn-select-container {
            display: flex;
            flex-direction: column;
        }

        .knn-params {
            display: flex;
            flex-direction: column;
        }

        .knn-buttons {
            display: flex;
            gap: 10px;
        }

        .knn-results {
            margin-top: 15px;
            font-family: 'Open Sans';
        }
    </style>
</head>
<body>
    <div class="sidebar" style="width: 300px;">
        <div class="block">
            <a href="index.html" style="text-align: center;">
                <img src="images/home.svg" width="20%" height="20%">
            </a>
        </div>
        <hr style="width: 80%;">
        <div class="block">
            <h1>Insert</h1>
            <div class="popup-menu">
                <a href="#" id="showDataFrameLink">DataFrame</a>
            </div>
        </div>
        <div class="block">
            <h1>Modeling</h1>
            <div class="popup-menu">
                <a href="#" id="knnOption">KNN Prediction</a>
            </div>
        </div>
        <div class="block">
            <h1>Analysis</h1>
            <div class="popup-menu">
                <a href="#" id="descriptiveStatsOption">Descriptive Statistics</a>
                <a href="#" id="correlationAnalysisOption">Correlation Analysis</a>
            </div>
        </div>
        <div class="block">
            <h1>Transformation</h1>
            <div class="popup-menu">
                <a href="#" id="transposeOption">Transpose</a>
                <a href="#" id="multiplyColumnsOption">Multiply Columns</a>
                <a href="#" id="squareValuesOption">Square Values</a>
                <a href="#" id="squareRootOption">Square Root</a>
                <a href="#" id="capitalizeTextOption">Capitalize Text</a>
                <a href="#" id="reverseTextOption">Reverse Text</a>
                <a href="#" id="labelEncodingOption">Label Encoding</a>
                <a href="#" id="appendStringOption">Append String</a>
            </div>
        </div>
        <div class="block">
            <h1>Visualization</h1>
        </div>
        <div class="block">
            <h1>Cleaning</h1>
            <div class="popup-menu">
                <a href="#" id="handleMissingValues">Missing Values</a>
                <a href="#" id="removeDuplicates">Remove Duplicates</a>
                <a href="#" id="standardizeText">Standardize Text</a>
                <a href="#" id="convertToNumeric">Convert to Numeric</a>
            </div>
        </div>
        <hr style="width: 80%;">
        <div class="block">
            <a href="" style="text-align: center;">
                <img src="images/settings.svg" width="20%" height="20%">
            </a>
        </div>
    </div>

    <div id="mainContentArea" class="main-content">
        <div id="importSection">
            <p style="font-family: 'Open Sans'; font-weight: 500; font-size: 2em; margin-bottom: 0;">Your report is empty</p>
            <p style="font-family: 'Open Sans'; font-weight: 500; font-size: 1em;">Add data to your report</p>
            <div class="flex-container1">
                <div class="card" style="background-color: #2173465b">
                    <div class="card-details">
                        <img src="images/excel.svg" style="height: 100%; width: 100%;">
                    </div>
                    <button class="card-button" id="excelImportButton">Import from Excel</button>
                </div>
                <div class="card" style="background-color: #fff2005b">
                    <div class="card-details">
                        <img src="images/sql-database.svg" alt="" style="height: 100%; width: 100%;">
                    </div>
                    <button class="card-button" id="sqlImportButton">Import from SQL</button>
                </div>
                <div class="card" style="background-color: #6b460075">
                    <div class="card-details">
                        <img src="images/powerbi.svg" alt="" style="height: 100%; width: 100%;">
                    </div>
                    <button class="card-button">Import from PowerBI</button>
                </div>
                <div class="card" style="background-color: #6c6c6c32">
                    <div class="card-details">
                        <img src="images/sample.svg" alt="" style="height: 100%; width: 100%;">
                    </div>
                    <button class="card-button">Import Sample Data</button>
                </div>
            </div>
            <a href="" style="text-decoration: none;">
                <p style="color: #00bfff; font-size: 1.5em;">Get data from another source →</p>
            </a>
        </div>

        <div id="dataframeSection" style="display: none; width: 100%; align-items: center; flex-direction: column;">
            <div class="project-title" contenteditable="true"></div>

            <div style="display: flex; align-items: flex-start; width: auto; justify-content: center;">
                <table id="dynamicTable" border="1">
                    <thead>
                        <tr>
                            <th class="row-number"></th>
                            <th contenteditable="true" style="background-color: #0d8bf1; font-weight: bold;">Feature 1</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="row-number">1</td>
                            <td contenteditable="true"></td>
                        </tr>
                    </tbody>
                </table>
                <button id="addColumn" style="margin-left: 10px; height: 30px;">+</button>
            </div>

            <div style="margin-top: 10px;">
                <button id="addRow" style="margin-top: 10px;">+</button>
                <button id="removeLastRow">-</button>
            </div>
            <div id="stats-sections-container"></div>
        </div>
    </div>

    <div class="dialog-backdrop" id="missingValuesBackdrop"></div>
    <div id="missingValuesDialog" class="cleaning-dialog">
        <h3 style="margin-top: 0;">Handle Missing Values</h3>
        <label for="missingValuesColumn">Column:</label>
        <select id="missingValuesColumn"></select>
        <div id="imputationMethods">
            <label for="handlingMethod">Method:</label>
            <select id="handlingMethod">
                <option value="impute">Impute Values</option>
                <option value="remove">Remove Rows</option>
            </select>
            <div id="imputationOptions" style="margin-top: 10px;">
                <label for="imputationType">Imputation Type:</label>
                <select id="imputationType">
                    <option value="mean">Mean</option>
                    <option value="median">Median</option>
                    <option value="mode">Mode</option>
                    <option value="previous">Previous Value</option>
                </select>
            </div>
        </div>
        <div class="cleaning-dialog-buttons">
            <button id="cancelMissingValuesBtn" class="cancelButton">Cancel</button>
            <button id="confirmMissingValuesBtn">Confirm</button>
        </div>
    </div>

    <div class="dialog-backdrop" id="columnActionBackdrop"></div>
    <div id="columnActionDialog" class="cleaning-dialog">
        <h3 id="columnActionTitle" style="margin-top: 0;"></h3>
        <label for="actionColumnSelect">Column:</label>
        <select id="actionColumnSelect"></select>
        <div class="cleaning-dialog-buttons">
            <button id="cancelColumnActionBtn" class="cancelButton">Cancel</button>
            <button id="confirmColumnActionBtn">Confirm</button>
        </div>
    </div>

    <div class="dialog-backdrop" id="multiplyColumnsBackdrop"></div>
    <div id="multiplyColumnsDialog" class="cleaning-dialog">
        <h3 style="margin-top: 0;">Multiply Columns</h3>
        <label for="multiplyColumn1">Select Column 1:</label>
        <select id="multiplyColumn1"></select>
        <label for="multiplyColumn2">Select Column 2:</label>
        <select id="multiplyColumn2"></select>
        <div class="cleaning-dialog-buttons">
            <button id="cancelMultiplyColumnsBtn" class="cancelButton">Cancel</button>
            <button id="confirmMultiplyColumnsBtn">Confirm</button>
        </div>
    </div>

    <div class="dialog-backdrop" id="appendStringBackdrop"></div>
    <div id="appendStringDialog" class="cleaning-dialog">
        <h3 style="margin-top: 0;">Append String</h3>
        <label for="appendColumnSelect">Column:</label>
        <select id="appendColumnSelect"></select>
        <label for="appendStringInput">String to Append/Prepend:</label>
        <input type="text" id="appendStringInput">
        <label for="appendPosition">Position:</label>
        <select id="appendPosition">
            <option value="append">Append</option>
            <option value="prepend">Prepend</option>
        </select>
        <div class="cleaning-dialog-buttons">
            <button id="cancelAppendStringBtn" class="cancelButton">Cancel</button>
            <button id="confirmAppendStringBtn">Confirm</button>
        </div>
    </div>

    <div class="dialog-backdrop" id="duplicateBackdrop"></div>
    <div id="duplicateConfirmation" class="cleaning-dialog">
        <h3>Remove Duplicates</h3>
        <p>Are you sure you want to remove duplicate rows?</p>
        <div class="cleaning-dialog-buttons">
            <button id="cancelDuplicateBtn" class="cancelButton">Cancel</button>
            <button id="confirmDuplicateBtn">Confirm</button>
        </div>
    </div>

    <div id="column-context-menu" class="context-menu">
        <div id="remove-column-option">Remove Column</div>
    </div>
    <div id="row-context-menu" class="context-menu">
        <div id="remove-row-option">Delete Row</div>
    </div>

    <script>
        const XLSX = require('xlsx');
        document.getElementById('excelImportButton').addEventListener('click', function(e) {
            e.preventDefault();
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.xlsx, .xls';

            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const buffer = await file.arrayBuffer();

                    const workbook = XLSX.read(buffer, { type: 'array' });

                    const worksheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[worksheetName];

                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                    const table = document.getElementById('dynamicTable');
                    const thead = table.querySelector('thead');
                    const tbody = table.querySelector('tbody');
                    thead.innerHTML = '';
                    tbody.innerHTML = '';

                    const headerRow = document.createElement('tr');
                    headerRow.innerHTML = '<th class="row-number"></th>';

                    if (jsonData.length > 0) {
                        jsonData[0].forEach((header, index) => {
                            const th = document.createElement('th');
                            th.contentEditable = true;
                            th.style.backgroundColor = "#0d8bf1";
                            th.style.fontWeight = "bold";
                            th.textContent = header?.toString() || `Feature ${index + 1}`;
                            headerRow.appendChild(th);
                        });
                    }
                    thead.appendChild(headerRow);

                    for (let i = 1; i < jsonData.length; i++) {
                        const tr = document.createElement('tr');
                        tr.innerHTML = `<td class="row-number">${i}</td>`;

                        jsonData[i].forEach(cell => {
                            const td = document.createElement('td');
                            td.contentEditable = true;
                            td.textContent = cell?.toString() || '';
                            tr.appendChild(td);
                        });

                        tbody.appendChild(tr);
                    }

                    document.getElementById('importSection').style.display = 'none';
                    document.getElementById('dataframeSection').style.display = 'flex';
                    updateRowNumbers();
                    updateColumnSelect();

                } catch (error) {
                    alert('Error processing Excel file: ' + error.message);
                    console.error('Excel import error:', error);
                }
            };
            input.click();
        });

        // SQL Import Functionality
        document.getElementById('sqlImportButton').addEventListener('click', function(e) {
            e.preventDefault();
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.sqlite, .db';

            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const uInt8Array = new Uint8Array(arrayBuffer);

                    // Initialize sql.js
                    const SQL = await initSqlJs({
                        locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
                    });
                    const db = new SQL.Database(uInt8Array);

                    // Get all table names
                    const tableQuery = db.exec("SELECT name FROM sqlite_master WHERE type='table';");
                    const tables = tableQuery[0]?.values?.map(row => row[0]) || [];

                    if (tables.length === 0) {
                        alert('No tables found in the database.');
                        db.close();
                        return;
                    }

                    // For simplicity, use the first table found
                    const tableName = tables[0];
                    const result = db.exec(`SELECT * FROM ${tableName}`);

                    if (!result[0]) {
                        alert('No data found in the table.');
                        db.close();
                        return;
                    }

                    const columns = result[0].columns;
                    const values = result[0].values;

                    // Populate the dynamicTable
                    const table = document.getElementById('dynamicTable');
                    const thead = table.querySelector('thead');
                    const tbody = table.querySelector('tbody');
                    thead.innerHTML = '';
                    tbody.innerHTML = '';

                    // Create header row
                    const headerRow = document.createElement('tr');
                    headerRow.innerHTML = '<th class="row-number"></th>';
                    columns.forEach((header, index) => {
                        const th = document.createElement('th');
                        th.contentEditable = true;
                        th.style.backgroundColor = "#0d8bf1";
                        th.style.fontWeight = "bold";
                        th.textContent = header?.toString() || `Feature ${index + 1}`;
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);

                    // Create data rows
                    values.forEach((row, rowIndex) => {
                        const tr = document.createElement('tr');
                        tr.innerHTML = `<td class="row-number">${rowIndex + 1}</td>`;
                        row.forEach(cell => {
                            const td = document.createElement('td');
                            td.contentEditable = true;
                            td.textContent = cell?.toString() || '';
                            tr.appendChild(td);
                        });
                        tbody.appendChild(tr);
                    });

                    // Hide import section and show dataframe section
                    document.getElementById('importSection').style.display = 'none';
                    document.getElementById('dataframeSection').style.display = 'flex';
                    updateRowNumbers();
                    updateColumnSelect();
                    updateKnnSelects();

                    // Clean up
                    db.close();

                } catch (error) {
                    alert('Error processing SQL file: ' + error.message);
                    console.error('SQL import error:', error);
                }
            };
            input.click();
        });

        function calculateMean(values) {
            if (values.length === 0) return 0;
            const sum = values.reduce((acc, val) => acc + val, 0);
            return sum / values.length;
        }

        function calculateMedian(values) {
            if (values.length === 0) return 0;
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        }

        function calculateMode(values) {
            const frequency = {};
            let maxFreq = 0;
            let modes = [];

            values.forEach(value => {
                frequency[value] = (frequency[value] || 0) + 1;
                if (frequency[value] > maxFreq) {
                    maxFreq = frequency[value];
                    modes = [value];
                } else if (frequency[value] === maxFreq) {
                    modes.push(value);
                }
            });

            return modes.length === values.length ? [] : modes;
        }

        function calculateStdDev(values, mean) {
            if (values.length <= 1) return 0;
            const currentMean = (mean === undefined) ? calculateMean(values) : mean;
            const variance = values.reduce((acc, val) => acc + Math.pow(val - currentMean, 2), 0) / (values.length - 1);
            return Math.sqrt(variance);
        }

        function updateRowNumbers() {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            rows.forEach((row, index) => {
                row.querySelector('.row-number').textContent = index + 1;
            });
        }

        function updateFeatureNames() {
            const headers = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');
            let featureCount = 1;

            headers.forEach((header) => {
                if (!header.textContent.trim() || /^Feature \d+$/.test(header.textContent)) {
                    header.textContent = `Feature ${featureCount}`;
                }
                featureCount++;
            });
        }

        function updateColumnSelect() {
            const allSelects = document.querySelectorAll('#stats-sections-container select, #missingValuesColumn, #actionColumnSelect, #multiplyColumn1, #multiplyColumn2, #appendColumnSelect');
            const headerCells = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');

            allSelects.forEach(select => {
                const currentSelectedIndex = select.selectedIndex;
                select.innerHTML = '';

                if (headerCells.length === 0) return;

                headerCells.forEach((header, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.text = header.textContent || `Column ${index + 1}`;
                    select.appendChild(option);
                });

                if (currentSelectedIndex !== -1 && currentSelectedIndex < select.options.length) {
                    select.selectedIndex = currentSelectedIndex;
                } else if (select.options.length > 0) {
                    const isSecondCorrelationSelect = select.parentElement &&
                        select.parentElement.querySelector('label:first-of-type') &&
                        select.parentElement.querySelector('label:first-of-type').textContent.includes('Column 1') &&
                        select.previousElementSibling && select.previousElementSibling.tagName === 'LABEL' && select.previousElementSibling.textContent.includes('Column 2');

                    if (isSecondCorrelationSelect && select.options.length > 1) {
                        select.selectedIndex = 1;
                    } else {
                        select.selectedIndex = 0;
                    }
                }
            });
        }

        const projectTitle = document.querySelector('.project-title');

        projectTitle.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                projectTitle.blur();
            }
        });

        projectTitle.addEventListener('input', (e) => {
            localStorage.setItem('projectName', e.target.textContent);
        });

        document.addEventListener('DOMContentLoaded', () => {
            const savedName = localStorage.getItem('projectName');
            if (savedName) {
                projectTitle.textContent = savedName;
            }
        });

        let currentCleaningAction = null;

        document.getElementById('handlingMethod').addEventListener('change', function() {
            const imputationOptions = document.getElementById('imputationOptions');
            imputationOptions.style.display = this.value === 'impute' ? 'block' : 'none';
        });

        function showMissingValuesDialog() {
            document.getElementById('missingValuesBackdrop').style.display = 'block';
            document.getElementById('missingValuesDialog').style.display = 'block';
            populateColumnSelect('missingValuesColumn');
            const methodSelect = document.getElementById('handlingMethod');
            const imputationOptions = document.getElementById('imputationOptions');
            imputationOptions.style.display = methodSelect.value === 'impute' ? 'block' : 'none';
        }

        function showColumnActionDialog(title) {
            document.getElementById('columnActionBackdrop').style.display = 'block';
            document.getElementById('columnActionDialog').style.display = 'block';
            document.getElementById('columnActionTitle').textContent = title;
            populateColumnSelect('actionColumnSelect');
        }

        function showMultiplyColumnsDialog() {
            document.getElementById('multiplyColumnsBackdrop').style.display = 'block';
            document.getElementById('multiplyColumnsDialog').style.display = 'block';
            populateColumnSelect('multiplyColumn1');
            populateColumnSelect('multiplyColumn2');
        }

        function showAppendStringDialog() {
            document.getElementById('appendStringBackdrop').style.display = 'block';
            document.getElementById('appendStringDialog').style.display = 'block';
            populateColumnSelect('appendColumnSelect');
            document.getElementById('appendStringInput').value = '';
            document.getElementById('appendPosition').selectedIndex = 0;
        }

        function hideAllDialogs() {
            document.querySelectorAll('.dialog-backdrop').forEach(d => d.style.display = 'none');
            document.querySelectorAll('.cleaning-dialog').forEach(d => d.style.display = 'none');
        }

        function populateColumnSelect(selectId) {
            const select = document.getElementById(selectId);
            select.innerHTML = '';
            const headers = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');
            headers.forEach((header, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = header.textContent;
                select.appendChild(option);
            });
        }

        function handleMissingValues() {
            const colIndex = parseInt(document.getElementById('missingValuesColumn').value);
            const method = document.getElementById('handlingMethod').value;

            if (method === 'remove') {
                const rows = document.querySelectorAll('#dynamicTable tbody tr');
                rows.forEach(row => {
                    const cell = row.cells[colIndex + 1];
                    if (!cell.textContent.trim()) {
                        row.remove();
                    }
                });
                updateRowNumbers();
            } else {
                const imputationType = document.getElementById('imputationType').value;
                const rows = document.querySelectorAll('#dynamicTable tbody tr');
                let imputeValue = null;
                let previousValue = null;

                const numericValues = [];
                rows.forEach(row => {
                    const cell = row.cells[colIndex + 1];
                    const value = parseFloat(cell.textContent);
                    if (!isNaN(value)) {
                        numericValues.push(value);
                    }
                });

                switch (imputationType) {
                    case 'mean':
                        imputeValue = numericValues.length > 0 ? calculateMean(numericValues) : 0;
                        break;
                    case 'median':
                        imputeValue = numericValues.length > 0 ? calculateMedian(numericValues) : 0;
                        break;
                    case 'mode':
                        const modes = calculateMode(numericValues);
                        imputeValue = modes.length > 0 ? modes[0] : 'N/A';
                        break;
                }

                rows.forEach(row => {
                    const cell = row.cells[colIndex + 1];
                    if (!cell.textContent.trim()) {
                        if (imputationType === 'previous') {
                            if (previousValue !== null) {
                                cell.textContent = previousValue;
                            }
                        } else {
                            cell.textContent = imputeValue;
                        }
                    } else {
                        previousValue = imputationType === 'previous' ? cell.textContent : previousValue;
                    }
                });
            }
            hideAllDialogs();
        }

        function standardizeText(colIndex) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                cell.textContent = cell.textContent.trim().toLowerCase();
            });
        }

        function convertToNumeric(colIndex) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            let hasInvalid = false;

            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                let original = cell.textContent.trim();

                if (original === '') return;

                original = original.replace(/^"(.*)"$/, '$1');

                if (original.startsWith('INVALID: ')) return;

                const number = parseFloat(original);

                if (isNaN(number)) {
                    cell.textContent = 'INVALID: ' + original;
                    hasInvalid = true;
                } else {
                    cell.textContent = number.toString();
                }
            });

            if (hasInvalid) {
                alert('Some values couldn\'t be converted. Invalid entries are marked with "INVALID: " prefix.');
            }
        }

        function squareValues(colIndex) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            const headerRow = document.querySelector('#dynamicTable thead tr');
            const header = headerRow.cells[colIndex + 1].textContent;
            const newHeader = document.createElement('th');
            newHeader.contentEditable = true;
            newHeader.style.backgroundColor = '#0d8bf1';
            newHeader.style.fontWeight = 'bold';
            newHeader.textContent = `Square of ${header}`;
            headerRow.appendChild(newHeader);

            let hasInvalid = false;
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                const newCell = document.createElement('td');
                newCell.contentEditable = true;
                const value = parseFloat(cell.textContent.trim());
                if (!isNaN(value)) {
                    newCell.textContent = (value * value).toString();
                } else {
                    newCell.textContent = 'INVALID';
                    hasInvalid = true;
                }
                row.appendChild(newCell);
            });

            if (hasInvalid) {
                alert('Some values couldn\'t be squared. Invalid entries are marked with "INVALID".');
            }
            updateColumnSelect();
            updateKnnSelects();
        }

        function squareRoot(colIndex) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            const headerRow = document.querySelector('#dynamicTable thead tr');
            const header = headerRow.cells[colIndex + 1].textContent;
            const newHeader = document.createElement('th');
            newHeader.contentEditable = true;
            newHeader.style.backgroundColor = '#0d8bf1';
            newHeader.style.fontWeight = 'bold';
            newHeader.textContent = `Sqrt of ${header}`;
            headerRow.appendChild(newHeader);

            let hasInvalid = false;
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                const newCell = document.createElement('td');
                newCell.contentEditable = true;
                const value = parseFloat(cell.textContent.trim());
                if (!isNaN(value) && value >= 0) {
                    newCell.textContent = Math.sqrt(value).toString();
                } else {
                    newCell.textContent = 'INVALID';
                    hasInvalid = true;
                }
                row.appendChild(newCell);
            });

            if (hasInvalid) {
                alert('Some values couldn\'t be processed (negatives or non-numeric). Invalid entries are marked with "INVALID".');
            }
            updateColumnSelect();
            updateKnnSelects();
        }

        function capitalizeText(colIndex) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                const text = cell.textContent.trim();
                if (text) {
                    cell.textContent = text
                        .split(' ')
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                        .join(' ');
                }
            });
        }

        function reverseText(colIndex) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                const text = cell.textContent.trim();
                if (text) {
                    cell.textContent = text.split('').reverse().join('');
                }
            });
        }

        function labelEncoding(colIndex) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            const headerRow = document.querySelector('#dynamicTable thead tr');
            const header = headerRow.cells[colIndex + 1].textContent;
            const newHeader = document.createElement('th');
            newHeader.contentEditable = true;
            newHeader.style.backgroundColor = '#0d8bf1';
            newHeader.style.fontWeight = 'bold';
            newHeader.textContent = `Encoded ${header}`;
            headerRow.appendChild(newHeader);

            const uniqueValues = new Set();
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                uniqueValues.add(cell.textContent.trim());
            });

            const labelMap = {};
            Array.from(uniqueValues).forEach((value, index) => {
                labelMap[value] = index;
            });

            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                const newCell = document.createElement('td');
                newCell.contentEditable = true;
                const value = cell.textContent.trim();
                newCell.textContent = labelMap[value].toString();
                row.appendChild(newCell);
            });

            updateColumnSelect();
            updateKnnSelects();
        }

        function appendString(colIndex, appendText, position) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                const text = cell.textContent.trim();
                if (text || appendText) {
                    cell.textContent = position === 'append' ? text + appendText : appendText + text;
                }
            });
        }

        function showRemovalFeedback(removedCount) {
            if (removedCount > 0) {
                alert(`${removedCount} duplicate rows were removed.`);
            } else {
                alert("No duplicate rows found.");
            }
        }

        function removeDuplicates() {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            const seen = new Set();
            let removedCount = 0;

            Array.from(rows).reverse().forEach(row => {
                const cells = Array.from(row.cells)
                    .slice(1)
                    .map(cell => cell.textContent.trim().toLowerCase());
                const key = cells.join('|');

                if (seen.has(key)) {
                    row.remove();
                    removedCount++;
                } else {
                    seen.add(key);
                }
            });

            updateRowNumbers();
            return removedCount;
        }

    function transposeTable() {
        const table = document.getElementById('dynamicTable');
        const thead = table.querySelector('thead');
        const tbody = table.querySelector('tbody');
        const rows = Array.from(tbody.rows);
        const headers = Array.from(thead.rows[0].cells).slice(1); // Exclude row-number column

        // Create a 2D array including headers as the first row
        const data = [
            headers.map(header => header.textContent), // Headers as first row
            ...rows.map(row => Array.from(row.cells).slice(1).map(cell => cell.textContent)) // Data rows
        ];

        // Transpose the data
        const transposedData = data[0].map((_, colIndex) => data.map(row => row[colIndex] || ''));

        // Clear the table
        thead.innerHTML = '';
        tbody.innerHTML = '';

        // Create new header row
        const newHeaderRow = document.createElement('tr');
        newHeaderRow.innerHTML = '<th class="row-number"></th>';

        // Use the first column of transposed data as headers, or fallback to "Feature X"
        if (transposedData.length > 0) {
            for (let i = 0; i < transposedData[0].length; i++) {
                const th = document.createElement('th');
                th.contentEditable = true;
                th.style.backgroundColor = "#0d8bf1";
                th.style.fontWeight = "bold";
                th.textContent = transposedData[0][i] || `Feature ${i + 1}`;
                newHeaderRow.appendChild(th);
            }
        }
        thead.appendChild(newHeaderRow);

        // Create new data rows, starting from the second row of transposed data
        for (let i = 1; i < transposedData.length; i++) {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td class="row-number">${i}</td>`;
            for (let j = 0; j < transposedData[i].length; j++) {
                const td = document.createElement('td');
                td.contentEditable = true;
                td.textContent = transposedData[i][j] || '';
                tr.appendChild(td);
            }
            tbody.appendChild(tr);
        }

        // Update row numbers and column selects
        updateRowNumbers();
        updateColumnSelect();
        updateKnnSelects();
    }

        function multiplyColumns() {
            const colIndex1 = parseInt(document.getElementById('multiplyColumn1').value);
            const colIndex2 = parseInt(document.getElementById('multiplyColumn2').value);
            const headers = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');
            const colName1 = headers[colIndex1].textContent;
            const colName2 = headers[colIndex2].textContent;

            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            const products = [];

            for (let i = 0; i < rows.length; i++) {
                const cell1 = rows[i].cells[colIndex1 + 1];
                const cell2 = rows[i].cells[colIndex2 + 1];
                const val1 = parseFloat(cell1.textContent);
                const val2 = parseFloat(cell2.textContent);
                if (!isNaN(val1) && !isNaN(val2)) {
                    products.push(val1 * val2);
                } else {
                    products.push('NaN');
                }
            }

            // Add new column
            const headerRow = document.querySelector('#dynamicTable thead tr');
            const newHeader = document.createElement('th');
            newHeader.contentEditable = true;
            newHeader.style.backgroundColor = "#0d8bf1";
            newHeader.style.fontWeight = "bold";
            newHeader.textContent = `Product of ${colName1} and ${colName2}`;
            headerRow.appendChild(newHeader);

            rows.forEach((row, index) => {
                const newCell = document.createElement('td');
                newCell.contentEditable = true;
                newCell.textContent = products[index];
                row.appendChild(newCell);
            });

            hideAllDialogs();
            updateColumnSelect();
            updateKnnSelects();
        }

        document.addEventListener('DOMContentLoaded', () => {
            const duplicateConfirmation = document.getElementById('duplicateConfirmation');
            const duplicateBackdrop = document.getElementById('duplicateBackdrop');

            document.getElementById('removeDuplicates').addEventListener('click', (e) => {
                e.preventDefault();
                duplicateConfirmation.style.display = 'block';
                duplicateBackdrop.style.display = 'block';
            });

            document.getElementById('confirmDuplicateBtn').addEventListener('click', () => {
                const removedCount = removeDuplicates();
                duplicateConfirmation.style.display = 'none';
                duplicateBackdrop.style.display = 'none';
                showRemovalFeedback(removedCount);
            });

            document.getElementById('cancelDuplicateBtn').addEventListener('click', () => {
                duplicateConfirmation.style.display = 'none';
                duplicateBackdrop.style.display = 'none';
            });

            duplicateBackdrop.addEventListener('click', () => {
                duplicateConfirmation.style.display = 'none';
                duplicateBackdrop.style.display = 'none';
            });

            document.getElementById('transposeOption').addEventListener('click', (e) => {
                e.preventDefault();
                transposeTable();
            });

            document.getElementById('multiplyColumnsOption').addEventListener('click', (e) => {
                e.preventDefault();
                showMultiplyColumnsDialog();
            });

            document.getElementById('squareValuesOption').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'square';
                showColumnActionDialog('Square Values');
            });

            document.getElementById('squareRootOption').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'sqrt';
                showColumnActionDialog('Square Root');
            });

            document.getElementById('capitalizeTextOption').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'capitalize';
                showColumnActionDialog('Capitalize Text');
            });

            document.getElementById('reverseTextOption').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'reverse';
                showColumnActionDialog('Reverse Text');
            });

            document.getElementById('labelEncodingOption').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'labelEncode';
                showColumnActionDialog('Label Encoding');
            });

            document.getElementById('appendStringOption').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'appendString';
                showAppendStringDialog();
            });

            document.getElementById('confirmMultiplyColumnsBtn').addEventListener('click', multiplyColumns);
            document.getElementById('cancelMultiplyColumnsBtn').addEventListener('click', hideAllDialogs);

            document.getElementById('confirmAppendStringBtn').addEventListener('click', () => {
                const colIndex = parseInt(document.getElementById('appendColumnSelect').value);
                const appendText = document.getElementById('appendStringInput').value;
                const position = document.getElementById('appendPosition').value;
                appendString(colIndex, appendText, position);
                hideAllDialogs();
            });

            document.getElementById('cancelAppendStringBtn').addEventListener('click', hideAllDialogs);

            document.getElementById('confirmColumnActionBtn').addEventListener('click', () => {
                const colIndex = parseInt(document.getElementById('actionColumnSelect').value);
                if (currentCleaningAction === 'standardize') {
                    standardizeText(colIndex);
                } else if (currentCleaningAction === 'convert') {
                    convertToNumeric(colIndex);
                } else if (currentCleaningAction === 'square') {
                    squareValues(colIndex);
                } else if (currentCleaningAction === 'sqrt') {
                    squareRoot(colIndex);
                } else if (currentCleaningAction === 'capitalize') {
                    capitalizeText(colIndex);
                } else if (currentCleaningAction === 'reverse') {
                    reverseText(colIndex);
                } else if (currentCleaningAction === 'labelEncode') {
                    labelEncoding(colIndex);
                }
                hideAllDialogs();
            });
            document.getElementById('cancelColumnActionBtn').addEventListener('click', hideAllDialogs);

            document.querySelectorAll('.dialog-backdrop').forEach(backdrop => {
                backdrop.addEventListener('click', hideAllDialogs);
            });

            const showDataFrameLink = document.getElementById('showDataFrameLink');
            const importSection = document.getElementById('importSection');
            const dataframeSection = document.getElementById('dataframeSection');
            const addRowButton = document.getElementById('addRow');
            const removeLastRowButton = document.getElementById('removeLastRow');
            const table = document.getElementById('dynamicTable');
            const tableHead = table.querySelector('thead');
            const tableBody = table.querySelector('tbody');
            const addColumnButton = document.getElementById('addColumn');
            const descriptiveStatsOption = document.getElementById('descriptiveStatsOption');
            const correlationAnalysisOption = document.getElementById('correlationAnalysisOption');
            const knnOption = document.getElementById('knnOption');
            const statsSectionsContainer = document.getElementById('stats-sections-container');
            const columnContextMenu = document.getElementById('column-context-menu');
            const removeColumnOption = document.getElementById('remove-column-option');
            const rowContextMenu = document.getElementById('row-context-menu');
            const removeRowOption = document.getElementById('remove-row-option');

            document.getElementById('handleMissingValues').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'missing';
                showMissingValuesDialog();
            });

            document.getElementById('confirmMissingValuesBtn').addEventListener('click', handleMissingValues);

            if (showDataFrameLink) {
                showDataFrameLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    importSection.style.display = 'none';
                    dataframeSection.style.display = 'flex';
                    dataframeSection.style.flexDirection = 'column';
                    dataframeSection.style.alignItems = 'center';
                });
            }

            addRowButton.addEventListener('click', () => {
                const row = tableBody.insertRow();
                const numCols = tableHead.rows[0]?.cells.length || 2;

                const rowNumberCell = row.insertCell(0);
                rowNumberCell.className = 'row-number';
                rowNumberCell.textContent = tableBody.rows.length;

                for (let i = 1; i < numCols; i++) {
                    const cell = row.insertCell(i);
                    cell.contentEditable = true;
                }
                updateRowNumbers();
            });

            removeLastRowButton.addEventListener('click', () => {
                if (tableBody.rows.length > 1) {
                    tableBody.deleteRow(-1);
                    updateRowNumbers();
                } else {
                    alert("Cannot remove the last data row.");
                }
            });

            addColumnButton.addEventListener('click', () => {
                const headerRow = tableHead.rows[0];
                const bodyRows = tableBody.rows;
                if (!headerRow) return;

                const newHeader = document.createElement("th");
                newHeader.contentEditable = true;
                newHeader.style.backgroundColor = "#0d8bf1";
                newHeader.style.fontWeight = "bold";

                const currentColumnCount = headerRow.cells.length - 1;
                newHeader.textContent = `Feature ${currentColumnCount + 1}`;

                headerRow.appendChild(newHeader);

                for (let i = 0; i < bodyRows.length; i++) {
                    const newCell = document.createElement("td");
                    newCell.contentEditable = true;
                    bodyRows[i].appendChild(newCell);
                }
                updateColumnSelect();
                updateKnnSelects();
            });

            tableHead.addEventListener('input', (e) => {
                if (e.target.tagName === 'TH' && !e.target.classList.contains('row-number')) {
                    if (!e.target.textContent.trim()) {
                        const currentColumnCount = document.querySelectorAll('#dynamicTable thead th:not(.row-number)').length;
                        e.target.textContent = `Feature ${currentColumnCount}`;
                    }
                }
            });

            tableBody.addEventListener('contextmenu', (e) => {
                const targetCell = e.target.closest('.row-number');
                if (targetCell) {
                    e.preventDefault();
                    rowToRemoveIndex = targetCell.parentNode.rowIndex;
                    rowContextMenu.style.top = `${e.pageY}px`;
                    rowContextMenu.style.left = `${e.pageX}px`;
                    rowContextMenu.style.display = 'block';
                }
            });

            removeRowOption.addEventListener('click', () => {
                if (rowToRemoveIndex > -1) {
                    tableBody.deleteRow(rowToRemoveIndex - 1);
                    updateRowNumbers();
                }
                rowContextMenu.style.display = 'none';
                rowToRemoveIndex = -1;
            });

            document.addEventListener('click', (e) => {
                if (!rowContextMenu.contains(e.target)) {
                    rowContextMenu.style.display = 'none';
                }
            });

            tableHead.addEventListener('contextmenu', (event) => {
                const targetHeader = event.target.closest('th');
                if (targetHeader && tableHead.contains(targetHeader) && !targetHeader.classList.contains('row-number')) {
                    event.preventDefault();
                    if (tableHead.rows[0].cells.length <= 2) {
                        alert("Cannot remove the last column.");
                        columnContextMenu.style.display = 'none';
                        return;
                    }
                    columnToRemoveIndex = targetHeader.cellIndex;
                    columnContextMenu.style.top = `${event.pageY}px`;
                    columnContextMenu.style.left = `${event.pageX}px`;
                    columnContextMenu.style.display = 'block';
                } else {
                    columnContextMenu.style.display = 'none';
                }
            });

            document.addEventListener('click', (event) => {
                if (!columnContextMenu.contains(event.target)) {
                    columnContextMenu.style.display = 'none';
                }
            });

            let columnToRemoveIndex = -1;
            let rowToRemoveIndex = -1;

            removeColumnOption.addEventListener('click', () => {
                if (columnToRemoveIndex > 0 && tableHead.rows[0]?.cells.length > 2) {
                    tableHead.rows[0].deleteCell(columnToRemoveIndex);
                    for (let i = 0; i < tableBody.rows.length; i++) {
                        tableBody.rows[i].deleteCell(columnToRemoveIndex);
                    }
                    updateColumnSelect();
                    updateFeatureNames();
                    updateKnnSelects();
                }
                columnContextMenu.style.display = 'none';
                columnToRemoveIndex = -1;
            });

            correlationAnalysisOption.addEventListener('click', (e) => {
                e.preventDefault();
                const correlationSection = document.createElement('div');
                correlationSection.className = 'correlation-section';

                const label1 = document.createElement('label');
                label1.style.fontFamily = 'Open Sans';
                label1.textContent = 'Column 1:';
                const select1 = document.createElement('select');
                select1.className = 'correlation-column-select';

                const label2 = document.createElement('label');
                label2.style.fontFamily = 'Open Sans';
                label2.textContent = 'Column 2:';
                const select2 = document.createElement('select');
                select2.className = 'correlation-column-select';

                const calculateButton = document.createElement('button');
                calculateButton.textContent = 'Calculate Correlation';

                const correlationOutput = document.createElement('div');
                correlationOutput.className = 'correlation-output';
                correlationOutput.style.fontFamily = 'Open Sans';
                correlationOutput.style.fontSize = '1em';
                correlationOutput.style.marginTop = '5px';
                correlationOutput.style.width = '100%';

                const removeButton = document.createElement('button');
                removeButton.textContent = 'Remove';
                removeButton.className = 'remove-button';

                function populateCorrelationSelects(selectElement) {
                    const headerCells = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');
                    selectElement.innerHTML = '';
                    headerCells.forEach((header, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.text = header.textContent || `Column ${index + 1}`;
                        selectElement.appendChild(option);
                    });
                }

                populateCorrelationSelects(select1);
                populateCorrelationSelects(select2);

                if (select2.options.length > 1) {
                    select2.selectedIndex = 1;
                } else if (select2.options.length > 0) {
                    select2.selectedIndex = 0;
                }

                correlationSection.appendChild(label1);
                correlationSection.appendChild(select1);
                correlationSection.appendChild(label2);
                correlationSection.appendChild(select2);
                correlationSection.appendChild(calculateButton);
                correlationSection.appendChild(removeButton);
                correlationSection.appendChild(correlationOutput);
                statsSectionsContainer.appendChild(correlationSection);

                removeButton.addEventListener('click', () => {
                    statsSectionsContainer.removeChild(correlationSection);
                });

                calculateButton.addEventListener('click', () => {
                    const colIndex1 = parseInt(select1.value);
                    const colIndex2 = parseInt(select2.value);
                    const rows = tableBody.rows;
                    const values1 = [];
                    const values2 = [];

                    if (colIndex1 === colIndex2) {
                        correlationOutput.innerHTML = `<strong>Error:</strong> Please select two different columns.`;
                        return;
                    }

                    for (let i = 0; i < rows.length; i++) {
                        const cell1 = rows[i].cells[colIndex1 + 1];
                        const cell2 = rows[i].cells[colIndex2 + 1];
                        if (cell1 && cell2) {
                            const val1Text = cell1.innerText.trim();
                            const val2Text = cell2.innerText.trim();
                            if (val1Text !== '' && val2Text !== '') {
                                const val1 = parseFloat(val1Text);
                                const val2 = parseFloat(val2Text);
                                if (!isNaN(val1) && !isNaN(val2)) {
                                    values1.push(val1);
                                    values2.push(val2);
                                }
                            }
                        }
                    }

                    if (values1.length < 2) {
                        correlationOutput.innerHTML = `<strong>Error:</strong> Not enough valid numeric data pairs (found ${values1.length}). Need at least 2.`;
                        return;
                    }

                    const n = values1.length;
                    const mean1 = calculateMean(values1);
                    const mean2 = calculateMean(values2);
                    const stdDev1 = calculateStdDev(values1, mean1);
                    const stdDev2 = calculateStdDev(values2, mean2);

                    if (stdDev1 === 0 || stdDev2 === 0) {
                        correlationOutput.innerHTML = `<strong>Result:</strong> Correlation is undefined (one or both columns have zero standard deviation).`;
                        return;
                    }

                    let covarianceSum = 0;
                    for (let i = 0; i < n; i++) {
                        covarianceSum += (values1[i] - mean1) * (values2[i] - mean2);
                    }

                    const correlation = covarianceSum / ((n - 1) * stdDev1 * stdDev2);
                    const clampedCorrelation = Math.max(-1, Math.min(1, correlation));
                    correlationOutput.innerHTML = `<strong>Pearson Correlation:</strong> ${clampedCorrelation.toFixed(4)}`;
                });
            });

            descriptiveStatsOption.addEventListener('click', (e) => {
                e.preventDefault();
                const statsSection = document.createElement('div');
                statsSection.className = 'stats-section';

                const label = document.createElement('label');
                label.style.fontFamily = 'Open Sans';
                label.style.fontSize = '1em';
                label.textContent = 'Select a column:';

                const select = document.createElement('select');
                select.style.marginRight = '10px';

                const calculateButton = document.createElement('button');
                calculateButton.style.marginLeft = '10px';
                calculateButton.textContent = 'Calculate Stats';

                const statsOutput = document.createElement('div');
                statsOutput.className = 'stats-output';
                statsOutput.style.marginTop = '10px';
                statsOutput.style.fontFamily = 'Open Sans';
                statsOutput.style.fontSize = '1em';

                const removeButton = document.createElement('button');
                removeButton.textContent = 'Remove';
                removeButton.className = 'remove-button';

                removeButton.addEventListener('click', () => {
                    statsSectionsContainer.removeChild(statsSection);
                });

                const headerCells = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');
                select.innerHTML = '';
                for (let i = 0; i < headerCells.length; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.text = headerCells[i].textContent || `Column ${i + 1}`;
                    select.appendChild(option);
                }

                statsSection.appendChild(label);
                statsSection.appendChild(select);
                statsSection.appendChild(calculateButton);
                statsSection.appendChild(removeButton);
                statsSection.appendChild(statsOutput);
                statsSectionsContainer.appendChild(statsSection);

                calculateButton.addEventListener('click', () => {
                    const columnIndex = parseInt(select.value);
                    const rows = tableBody.rows;
                    const values = [];
                    for (let i = 0; i < rows.length; i++) {
                        const cell = rows[i].cells[columnIndex + 1];
                        if (cell) {
                            const valueText = cell.innerText.trim();
                            if (valueText !== '') {
                                const value = parseFloat(valueText);
                                if (!isNaN(value)) {
                                    values.push(value);
                                }
                            }
                        }
                    }

                    if (values.length === 0) {
                        statsOutput.innerHTML = 'No numeric data in this column.';
                        return;
                    }

                    const sum = values.reduce((a, b) => a + b, 0);
                    const avg = sum / values.length;
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const sorted = [...values].sort((a, b) => a - b);
                    const mid = Math.floor(sorted.length / 2);
                    const median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
                    const frequency = {};
                    let maxFreq = 0;
                    let mode = [];
                    values.forEach(value => {
                        frequency[value] = (frequency[value] || 0) + 1;
                        if (frequency[value] > maxFreq) {
                            maxFreq = frequency[value];
                        }
                    });

                    const allSameFrequency = Object.values(frequency).every(freq => freq === maxFreq);
                    if (maxFreq === 1 || (allSameFrequency && Object.keys(frequency).length > 1)) {
                        mode = ["No mode"];
                    } else {
                        for (const key in frequency) {
                            if (frequency[key] === maxFreq) {
                                mode.push(Number(key));
                            }
                        }
                    }

                    const variance = values.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / values.length;
                    const stdDev = Math.sqrt(variance);
                    statsOutput.innerHTML = `
                        <strong>Count:</strong> ${values.length}<br>
                        <strong>Sum:</strong> ${sum.toFixed(2)}<br>
                        <strong>Average:</strong> ${avg.toFixed(2)}<br>
                        <strong>Median:</strong> ${median.toFixed(2)}<br>
                        <strong>Mode:</strong> ${mode.join(', ')}<br>
                        <strong>Min:</strong> ${min}<br>
                        <strong>Max:</strong> ${max}<br>
                        <strong>Variance:</strong> ${variance.toFixed(2)}<br>
                        <strong>Standard Deviation:</strong> ${stdDev.toFixed(2)}`;
                });
            });

            knnOption.addEventListener('click', (e) => {
                e.preventDefault();
                const knnSection = createKnnSection();
                statsSectionsContainer.appendChild(knnSection);
            });

            table.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    const activeElement = document.activeElement;
                    if (activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                        const currentRow = activeElement.parentNode;
                        const currentCellIndex = activeElement.cellIndex;
                        const nextCellIndex = currentCellIndex + 1;
                        let nextCell = currentRow.cells[nextCellIndex];
                        if (nextCell && nextCell.contentEditable === 'true') {
                            nextCell.focus();
                        } else {
                            const nextRow = currentRow.nextElementSibling;
                            if (nextRow) {
                                let firstEditableCellInNextRow = null;
                                for (let i = 0; i < nextRow.cells.length; i++) {
                                    if (nextRow.cells[i].contentEditable === 'true') {
                                        firstEditableCellInNextRow = nextRow.cells[i];
                                        break;
                                    }
                                }
                                if (firstEditableCellInNextRow) {
                                    firstEditableCellInNextRow.focus();
                                } else {
                                    activeElement.blur();
                                }
                            } else {
                                activeElement.blur();
                            }
                        }
                    } else if (activeElement.tagName === 'TH' && activeElement.contentEditable === 'true') {
                        if (tableBody.rows.length > 0 && tableBody.rows[0].cells.length > 1 && tableBody.rows[0].cells[1].contentEditable === 'true') {
                            tableBody.rows[0].cells[1].focus();
                        } else {
                            activeElement.blur();
                        }
                    }
                }
            });

        });

        class StandardScaler {
            fitTransform(data) {
                this.means = [];
                this.stds = [];

                if (data.length === 0) return [];

                const numFeatures = data[0].length;
                for (let i = 0; i < numFeatures; i++) {
                    const featureValues = data.map(row => row[i]);
                    const mean = featureValues.reduce((a, b) => a + b, 0) / featureValues.length;
                    const std = Math.sqrt(featureValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / featureValues.length);

                    this.means.push(mean);
                    this.stds.push(std || 1);
                }

                return this.transform(data);
            }

            transform(data) {
                return data.map(row =>
                    row.map((val, i) =>
                        (val - this.means[i]) / this.stds[i]
                    )
                );
            }
        }

        class KNeighborsClassifier {
            constructor(k = 5) {
                this.k = k;
            }

            fit(X, y) {
                this.X_train = X;
                this.y_train = y;
            }

            predict(X_test) {
                return X_test.map(testPoint => {
                    const distances = this.X_train.map((trainPoint, i) => ({
                        label: this.y_train[i],
                        distance: Math.sqrt(
                            trainPoint.reduce((sum, val, j) =>
                                sum + Math.pow(val - testPoint[j], 2), 0)
                        )
                    }));

                    const nearest = distances
                        .sort((a, b) => a.distance - b.distance)
                        .slice(0, this.k);

                    const votes = {};
                    nearest.forEach(n => {
                        votes[n.label] = (votes[n.label] || 0) + 1;
                    });

                    return Object.entries(votes).sort((a, b) => b[1] - a[1])[0][0];
                });
            }
        }

        function createKnnSection() {
            const section = document.createElement('div');
            section.className = 'knn-section';

            const title = document.createElement('h3');
            title.textContent = 'KNN Prediction';
            section.appendChild(title);

            const controls = document.createElement('div');
            controls.className = 'knn-controls';

            const featuresContainer = document.createElement('div');
            featuresContainer.className = 'knn-select-container';
            const featuresLabel = document.createElement('label');
            featuresLabel.textContent = 'Features (Select Multiple):';
            const featuresSelect = document.createElement('select');
            featuresSelect.className = 'knn-features';
            featuresSelect.multiple = true;
            featuresSelect.style.width = '200px';
            featuresSelect.style.height = '100px';
            featuresContainer.appendChild(featuresLabel);
            featuresContainer.appendChild(featuresSelect);
            controls.appendChild(featuresContainer);

            const targetContainer = document.createElement('div');
            targetContainer.className = 'knn-select-container';
            const targetLabel = document.createElement('label');
            targetLabel.textContent = 'Target:';
            const targetSelect = document.createElement('select');
            targetSelect.className = 'knn-target';
            targetSelect.style.width = '200px';
            targetContainer.appendChild(targetLabel);
            targetContainer.appendChild(targetSelect);
            controls.appendChild(targetContainer);

            const paramsContainer = document.createElement('div');
            paramsContainer.className = 'knn-params';
            const kLabel = document.createElement('label');
            kLabel.textContent = 'Neighbors (K):';
            const kInput = document.createElement('input');
            kInput.type = 'number';
            kInput.className = 'k-value';
            kInput.min = '1';
            kInput.value = '5';
            kInput.style.width = '50px';
            paramsContainer.appendChild(kLabel);
            paramsContainer.appendChild(kInput);
            controls.appendChild(paramsContainer);

            section.appendChild(controls);

            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'knn-buttons';
            const makePredictionButton = document.createElement('button');
            makePredictionButton.className = 'make-prediction';
            makePredictionButton.textContent = 'Make Prediction';
            const resetButton = document.createElement('button');
            resetButton.className = 'reset-knn';
            resetButton.textContent = 'Reset';
            resetButton.style.backgroundColor = '#f44336';
            buttonsContainer.appendChild(makePredictionButton);
            buttonsContainer.appendChild(resetButton);
            section.appendChild(buttonsContainer);

            const resultsDiv = document.createElement('div');
            resultsDiv.className = 'knn-results';
            section.appendChild(resultsDiv);

            const removeButton = document.createElement('button');
            removeButton.textContent = 'Remove';
            removeButton.className = 'remove-button';
            removeButton.addEventListener('click', () => {
                const statsSectionsContainer = document.getElementById('stats-sections-container');
                statsSectionsContainer.removeChild(section);
            });
            section.appendChild(removeButton);

            populateKnnSelects(section);

            makePredictionButton.addEventListener('click', () => {
                trainAndPredict(section);
            });

            resetButton.addEventListener('click', () => {
                resetKnn(section);
            });

            return section;
        }

        function populateKnnSelects(section) {
            const featuresSelect = section.querySelector('.knn-features');
            const targetSelect = section.querySelector('.knn-target');
            const headerCells = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');

            featuresSelect.innerHTML = '';
            targetSelect.innerHTML = '';

            headerCells.forEach((header, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.text = header.textContent || `Column ${index + 1}`;
                featuresSelect.appendChild(option.cloneNode(true));
                targetSelect.appendChild(option);
            });
        }

        function updateKnnSelects() {
            const knnSections = document.querySelectorAll('.knn-section');
            knnSections.forEach(section => {
                populateKnnSelects(section);
            });
        }

        function trainAndPredict(section) {
            const featuresSelect = section.querySelector('.knn-features');
            const selectedFeatures = Array.from(featuresSelect.selectedOptions).map(opt => parseInt(opt.value));
            const targetSelect = section.querySelector('.knn-target');
            const selectedTarget = parseInt(targetSelect.value);
            const kInput = section.querySelector('.k-value');
            const kValue = parseInt(kInput.value);

            if (selectedFeatures.length === 0) {
                section.querySelector('.knn-results').innerHTML = "<strong>Error:</strong> Please select at least one feature";
                return;
            }

            const X_train = [], y_train = [];
            const X_all = [];
            const validRowIndices = [];

            const rows = document.querySelectorAll('#dynamicTable tbody tr');

            for (let i = 0; i < rows.length; i++) {
                const featureValues = [];
                let hasEmpty = false;

                for (const featureIndex of selectedFeatures) {
                    const cell = rows[i].cells[featureIndex + 1];
                    const valueText = cell?.innerText.trim();
                    if (!cell || valueText === '' || isNaN(parseFloat(valueText))) {
                        hasEmpty = true;
                        break;
                    }
                    featureValues.push(parseFloat(valueText));
                }

                if (!hasEmpty) {
                    const targetCell = rows[i].cells[selectedTarget + 1];
                    const targetValue = targetCell ? targetCell.innerText.trim() : '';

                    // If target is present, use for training
                    if (targetValue !== '') {
                        X_train.push(featureValues);
                        y_train.push(targetValue);
                    }

                    // Add to prediction list (we'll predict for all rows with full features)
                    X_all.push(featureValues);
                    validRowIndices.push(i);
                }
            }

            if (X_train.length < kValue || X_train.length === 0) {
                section.querySelector('.knn-results').innerHTML = `<strong>Error:</strong> Not enough valid training data (found ${X_train.length} rows, need at least ${kValue}).`;
                return;
            }

            if (X_all.length === 0) {
                section.querySelector('.knn-results').innerHTML = `<strong>Error:</strong> No rows found with valid features to predict.`;
                return;
            }

            const scaler = new StandardScaler();
            const X_train_scaled = scaler.fitTransform(X_train);
            const X_all_scaled = scaler.transform(X_all);

            const knn = new KNeighborsClassifier(kValue);
            knn.fit(X_train_scaled, y_train);

            const predictions = knn.predict(X_all_scaled);

            // Add prediction column to header
            const headerRow = document.querySelector('#dynamicTable thead tr');
            const newHeader = document.createElement('th');
            newHeader.contentEditable = true;
            newHeader.style.backgroundColor = '#0d8bf1';
            newHeader.style.fontWeight = 'bold';
            newHeader.textContent = 'KNN Prediction';
            headerRow.appendChild(newHeader);

            // Add predictions to corresponding rows
            rows.forEach((row, index) => {
                const newCell = document.createElement('td');
                newCell.contentEditable = true;
                const predIndex = validRowIndices.indexOf(index);
                newCell.textContent = predIndex !== -1 ? predictions[predIndex] : '';
                row.appendChild(newCell);
            });

            section.querySelector('.knn-results').innerHTML = `<strong>Success:</strong> Predictions added for all valid rows.`;
            updateColumnSelect();
            updateKnnSelects();
        }

        function resetKnn(section) {
            const featuresSelect = section.querySelector('.knn-features');
            const targetSelect = section.querySelector('.knn-target');
            const kInput = section.querySelector('.k-value');
            const resultsDiv = section.querySelector('.knn-results');

            featuresSelect.selectedIndex = -1;
            targetSelect.selectedIndex = 0;
            kInput.value = '5';
            resultsDiv.innerHTML = '';
        }

        document.getElementById('standardizeText').addEventListener('click', (e) => {
            e.preventDefault();
            currentCleaningAction = 'standardize';
            showColumnActionDialog('Standardize Text');
        });

        document.getElementById('convertToNumeric').addEventListener('click', (e) => {
            e.preventDefault();
            currentCleaningAction = 'convert';
            showColumnActionDialog('Convert to Numeric');
        });

        document.getElementById('cancelMissingValuesBtn').addEventListener('click', hideAllDialogs);
    </script>
</body>
</html>