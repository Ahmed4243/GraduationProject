<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="index.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@500&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/sql-wasm.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap');
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }

        .main-content {
            margin-left: 300px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        h1 {
            color: white;
        }

        .flex-container1 {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            gap: 20px;
            width: 100%;
        }

        .card {
            width: 150px;
            height: 200px;
            border-radius: 20px;
            background: #f5f5f5;
            border: 2px solid #c3c6ce;
            transition: 0.5s ease-out;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .project-title {
            font-family: 'Open Sans';
            font-weight: 500;
            font-size: 2em;
            cursor: text;
            padding: 8px 20px;
            border-radius: 8px;
            transition: all 0.2s ease;
            margin: 20px 0;
            border: 2px solid transparent;
            outline: none;
            min-width: 300px;
            text-align: center;
            background: transparent;
        }

        .project-title:hover {
            background: rgba(245, 245, 245, 0.6);
        }

        .project-title:focus {
            border: 2px solid #0d8bf1;
            background: white;
            box-shadow: 0 0 0 3px rgba(13, 139, 241, 0.15);
        }

        .project-title:empty::before {
            content: "Untitled Project";
            color: #888;
        }

        .project-title:focus:empty::before {
            content: "";
        }

        .card-details {
            padding: 5px;
            text-align: center;
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .card-details img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .card-button {
            width: 100%;
            padding: 8px 0;
            border: none;
            border-top: 1px solid #c3c6ce;
            background-color: #117c9f;
            cursor: pointer;
            font-size: 0.9em;
            font-family: 'Open Sans', sans-serif;
        }

        .block {
            margin-bottom: 20px;
            position: relative;
        }

        .block h1 {
            color: white;
            font-family: 'Open Sans', sans-serif;
            font-size: 1.4em;
            margin: 0;
            cursor: pointer;
        }

        .popup-menu {
            display: none;
            position: absolute;
            top: 0;
            left: 100%;
            background-color: white;
            box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 5px;
            padding: 20px;
            width: 230px;
            z-index: 1000;
            font-family: 'Open Sans', sans-serif;
            font-size: 1.4em;
            white-space: nowrap;
        }

        .popup-menu a {
            display: block;
            color: #34495e;
            text-decoration: none;
            margin: 10px 0;
            font-size: 1.1em;
        }

        .popup-menu a:hover {
            color: #00bfff;
        }

        .block:hover .popup-menu {
            display: block;
        }

        #dynamicTable {
            margin-bottom: 10px;
        }

        #dynamicTable th,
        #dynamicTable td {
            padding: 15px;
        }

        #dynamicTable td[contenteditable="true"]:focus {
            outline: 2px solid #f1960d;
        }

        #addColumn,
        #addRow,
        #removeLastRow {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }

        #addColumn {
            margin-left: 10px;
            height: 30px;
        }

        #addRow {
            margin-top: 10px;
        }

        #removeLastRow {
            background-color: #f44336;
        }

        #stats-sections-container {
            width: 100%;
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        #stats-sections-container > div {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 15px;
            width: auto;
            max-width: 90%;
        }

        #stats-sections-container label {
            font-family: 'Open Sans';
            font-size: 1em;
        }

        #stats-sections-container select {
            margin-right: 10px;
        }

        #stats-sections-container button {
            margin-left: 10px;
        }

        #stats-sections-container .remove-button {
            background-color: #f44336;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 5px 10px;
            cursor: pointer;
            margin-left: auto;
        }

        #stats-sections-container .stats-output,
        #stats-sections-container .correlation-output {
            margin-top: 10px;
            font-family: 'Open Sans';
            font-size: 1em;
            width: 100%;
            padding-top: 5px;
            line-height: 1.4;
        }

        #stats-sections-container .stats-output strong,
        #stats-sections-container .correlation-output strong {
            margin-right: 4px;
        }

        .context-menu {
            display: none;
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            padding: 5px 0;
            border-radius: 4px;
            min-width: 150px;
        }

        .context-menu div {
            padding: 8px 15px;
            cursor: pointer;
            font-family: 'Open Sans', sans-serif;
            font-size: 0.95em;
        }

        .context-menu div:hover {
            background-color: #f0f0f0;
        }

        .row-number {
            width: 40px !important;
            min-width: 40px !important;
            max-width: 40px !important;
            text-align: center;
            background-color: #f0f0f0 !important;
            user-select: none;
        }

        #dynamicTable th:first-child,
        #dynamicTable td:first-child {
            position: sticky;
            left: 0;
            z-index: 1;
        }

        .sidebar {
            height: 100%;
            width: 300px;
            background-color: #117c9f;
            box-shadow: 0 4px 25px 5px rgba(0, 0, 0, 0.5);
            position: fixed;
            top: 0;
            left: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 1000;
        }

        .cleaning-dialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.2);
            z-index: 1001;
            min-width: 300px;
        }

        .cleaning-dialog label {
            display: block;
            margin: 10px 0 5px;
            font-family: 'Open Sans';
        }

        .cleaning-dialog select,
        .cleaning-dialog input[type="text"] {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
        }

        .cleaning-dialog-buttons {
            margin-top: 15px;
            text-align: right;
        }

        .cleaning-dialog-buttons button {
            margin-left: 10px;
            padding: 8px 15px;
            cursor: pointer;
        }

        .cancelButton {
            background-color: red;
        }

        .dialog-backdrop {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }

        /* KNN Styles */
        .knn-section {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 15px;
            width: auto;
            max-width: 90%;
        }

        .knn-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .knn-select-container {
            display: flex;
            flex-direction: column;
        }

        .knn-params {
            display: flex;
            flex-direction: column;
        }

        .knn-buttons {
            display: flex;
            gap: 10px;
        }

        .knn-results {
            margin-top: 15px;
            font-family: 'Open Sans';
        }

        /* Linear Regression Styles */
        .lr-section {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 15px;
            width: auto;
            max-width: 90%;
        }

        .lr-controls {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 15px;
        }

        .lr-select-container {
            display: flex;
            flex-direction: column;
        }

        .lr-advanced-options {
            display: none;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background-color: #f9f9f9;
        }

        .lr-buttons {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .lr-results {
            margin-top: 15px;
            font-family: 'Open Sans';
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <div class="block">
            <a href="index.html" style="text-align: center;">
                <img src="images/home.svg" width="20%" height="20%">
            </a>
        </div>
        <hr style="width: 80%;">
        <div class="block">
            <h1>Insert</h1>
            <div class="popup-menu">
                <a href="#" id="showDataFrameLink">DataFrame</a>
            </div>
        </div>
        <div class="block">
            <h1>Modeling</h1>
            <div class="popup-menu">
                <a href="#" id="knnOption">KNN Prediction</a>
                <a href="#" id="linearRegressionOption">Linear Regression</a>
                <a href="#" id="kmeansOption">K-means Clustering</a>
                <a href="#" id="logisticOption">Logistic Regression</a>
            </div>
        </div>
        <div class="block">
            <h1>Analysis</h1>
            <div class="popup-menu">
                <a href="#" id="descriptiveStatsOption">Descriptive Statistics</a>
                <a href="#" id="correlationAnalysisOption">Correlation Analysis</a>
            </div>
        </div>
        <div class="block">
            <h1>Transformation</h1>
            <div class="popup-menu">
                <a href="#" id="transposeOption">Transpose</a>
                <a href="#" id="multiplyColumnsOption">Multiply Columns</a>
                <a href="#" id="squareValuesOption">Square Values</a>
                <a href="#" id="squareRootOption">Square Root</a>
                <a href="#" id="capitalizeTextOption">Capitalize Text</a>
                <a href="#" id="reverseTextOption">Reverse Text</a>
                <a href="#" id="labelEncodingOption">Label Encoding</a>
                <a href="#" id="appendStringOption">Append String</a>
            </div>
        </div>
        <div class="block">
            <h1>Visualization</h1>
        </div>
        <div class="block">
            <h1>Cleaning</h1>
            <div class="popup-menu">
                <a href="#" id="handleMissingValues">Missing Values</a>
                <a href="#" id="removeDuplicates">Remove Duplicates</a>
                <a href="#" id="standardizeText">Standardize Text</a>
                <a href="#" id="convertToNumeric">Convert to Numeric</a>
            </div>
        </div>
        <hr style="width: 80%;">
        <div class="block">
            <a href="" style="text-align: center;">
                <img src="images/settings.svg" width="20%" height="20%">
            </a>
        </div>
    </div>

    <div id="mainContentArea" class="main-content">
        <div id="importSection">
            <p style="font-family: 'Open Sans'; font-weight: 500; font-size: 2em; margin-bottom: 0;">Your report is empty</p>
            <p style="font-family: 'Open Sans'; font-weight: 500; font-size: 1em;">Add data to your report</p>
            <div class="flex-container1">
                <div class="card" style="background-color: #2173465b">
                    <div class="card-details">
                        <img src="images/excel.svg" style="height: 100%; width: 100%;">
                    </div>
                    <button class="card-button" id="excelImportButton">Import from Excel</button>
                </div>
                <div class="card" style="background-color: #fff2005b">
                    <div class="card-details">
                        <img src="images/sql-database.svg" alt="" style="height: 100%; width: 100%;">
                    </div>
                    <button class="card-button" id="sqlImportButton">Import from SQL</button>
                </div>
                <div class="card" style="background-color: #6b460075">
                    <div class="card-details">
                        <img src="images/powerbi.svg" alt="" style="height: 100%; width: 100%;">
                    </div>
                    <button class="card-button">Import from PowerBI</button>
                </div>
                <div class="card" style="background-color: #6c6c6c32">
                    <div class="card-details">
                        <img src="images/sample.svg" alt="" style="height: 100%; width: 100%;">
                    </div>
                    <button class="card-button">Import Sample Data</button>
                </div>
            </div>
            <a href="" style="text-decoration: none;">
                <p style="color: #00bfff; font-size: 1.5em;">Get data from another source →</p>
            </a>
        </div>

        <div id="dataframeSection" style="display: none; width: 100%; align-items: center; flex-direction: column;">
            <div class="project-title" contenteditable="true"></div>

            <div style="display: flex; align-items: flex-start; width: auto; justify-content: center;">
                <table id="dynamicTable" border="1">
                    <thead>
                        <tr>
                            <th class="row-number"></th>
                            <th contenteditable="true" style="background-color: #0d8bf1; font-weight: bold;">Feature 1</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="row-number">1</td>
                            <td contenteditable="true"></td>
                        </tr>
                    </tbody>
                </table>
                <button id="addColumn" style="margin-left: 10px; height: 30px;">+</button>
            </div>

            <div style="margin-top: 10px;">
                <button id="addRow" style="margin-top: 10px;">+</button>
                <button id="removeLastRow">-</button>
            </div>
            <div id="stats-sections-container"></div>
        </div>
    </div>

    <div class="dialog-backdrop" id="missingValuesBackdrop"></div>
    <div id="missingValuesDialog" class="cleaning-dialog">
        <h3 style="margin-top: 0;">Handle Missing Values</h3>
        <label for="missingValuesColumn">Column:</label>
        <select id="missingValuesColumn" class="column-select"></select>
        <div id="imputationMethods">
            <label for="handlingMethod">Method:</label>
            <select id="handlingMethod">
                <option value="impute">Impute Values</option>
                <option value="remove">Remove Rows</option>
            </select>
            <div id="imputationOptions" style="margin-top: 10px;">
                <label for="imputationType">Imputation Type:</label>
                <select id="imputationType">
                    <option value="mean">Mean</option>
                    <option value="median">Median</option>
                    <option value="mode">Mode</option>
                    <option value="previous">Previous Value</option>
                </select>
            </div>
        </div>
        <div class="cleaning-dialog-buttons">
            <button id="cancelMissingValuesBtn" class="cancelButton">Cancel</button>
            <button id="confirmMissingValuesBtn">Confirm</button>
        </div>
    </div>

    <div class="dialog-backdrop" id="columnActionBackdrop"></div>
    <div id="columnActionDialog" class="cleaning-dialog">
        <h3 id="columnActionTitle" style="margin-top: 0;"></h3>
        <label for="actionColumnSelect">Column:</label>
        <select id="actionColumnSelect" class="column-select"></select>
        <div class="cleaning-dialog-buttons">
            <button id="cancelColumnActionBtn" class="cancelButton">Cancel</button>
            <button id="confirmColumnActionBtn">Confirm</button>
        </div>
    </div>

    <div class="dialog-backdrop" id="multiplyColumnsBackdrop"></div>
    <div id="multiplyColumnsDialog" class="cleaning-dialog">
        <h3 style="margin-top: 0;">Multiply Columns</h3>
        <label for="multiplyColumn1">Select Column 1:</label>
        <select id="multiplyColumn1" class="column-select"></select>
        <label for="multiplyColumn2">Select Column 2:</label>
        <select id="multiplyColumn2" class="column-select"></select>
        <div class="cleaning-dialog-buttons">
            <button id="cancelMultiplyColumnsBtn" class="cancelButton">Cancel</button>
            <button id="confirmMultiplyColumnsBtn">Confirm</button>
        </div>
    </div>

    <div class="dialog-backdrop" id="appendStringBackdrop"></div>
    <div id="appendStringDialog" class="cleaning-dialog">
        <h3 style="margin-top: 0;">Append String</h3>
        <label for="appendColumnSelect">Column:</label>
        <select id="appendColumnSelect" class="column-select"></select>
        <label for="appendStringInput">String to Append/Prepend:</label>
        <input type="text" id="appendStringInput">
        <label for="appendPosition">Position:</label>
        <select id="appendPosition">
            <option value="append">Append</option>
            <option value="prepend">Prepend</option>
        </select>
        <div class="cleaning-dialog-buttons">
            <button id="cancelAppendStringBtn" class="cancelButton">Cancel</button>
            <button id="confirmAppendStringBtn">Confirm</button>
        </div>
    </div>

    <div class="dialog-backdrop" id="duplicateBackdrop"></div>
    <div id="duplicateConfirmation" class="cleaning-dialog">
        <h3>Remove Duplicates</h3>
        <p>Are you sure you want to remove duplicate rows?</p>
        <div class="cleaning-dialog-buttons">
            <button id="cancelDuplicateBtn" class="cancelButton">Cancel</button>
            <button id="confirmDuplicateBtn">Confirm</button>
        </div>
    </div>

    <div id="column-context-menu" class="context-menu">
        <div id="remove-column-option">Remove Column</div>
    </div>
    <div id="row-context-menu" class="context-menu">
        <div id="remove-row-option">Delete Row</div>
    </div>

    <script>
        const XLSX = require('xlsx');
        document.getElementById('excelImportButton').addEventListener('click', function(e) {
            e.preventDefault();
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.xlsx, .xls';

            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const buffer = await file.arrayBuffer();

                    const workbook = XLSX.read(buffer, { type: 'array' });

                    const worksheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[worksheetName];

                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

                    const table = document.getElementById('dynamicTable');
                    const thead = table.querySelector('thead');
                    const tbody = table.querySelector('tbody');
                    thead.innerHTML = '';
                    tbody.innerHTML = '';

                    const headerRow = document.createElement('tr');
                    headerRow.innerHTML = '<th class="row-number"></th>';

                    if (jsonData.length > 0) {
                        jsonData[0].forEach((header, index) => {
                            const th = document.createElement('th');
                            th.contentEditable = true;
                            th.style.backgroundColor = "#0d8bf1";
                            th.style.fontWeight = "bold";
                            th.textContent = header?.toString() || `Feature ${index + 1}`;
                            headerRow.appendChild(th);
                        });
                    }
                    thead.appendChild(headerRow);

                    for (let i = 1; i < jsonData.length; i++) {
                        const tr = document.createElement('tr');
                        tr.innerHTML = `<td class="row-number">${i}</td>`;

                        jsonData[i].forEach(cell => {
                            const td = document.createElement('td');
                            td.contentEditable = true;
                            td.textContent = cell?.toString() || '';
                            tr.appendChild(td);
                        });

                        tbody.appendChild(tr);
                    }

                    document.getElementById('importSection').style.display = 'none';
                    document.getElementById('dataframeSection').style.display = 'flex';
                    updateRowNumbers();
                    updateColumnSelect();

                } catch (error) {
                    alert('Error processing Excel file: ' + error.message);
                    console.error('Excel import error:', error);
                }
            };
            input.click();
        });

        document.getElementById('sqlImportButton').addEventListener('click', function(e) {
            e.preventDefault();
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.sqlite, .db';

            input.onchange = async function(e) {
                const file = e.target.files[0];
                if (!file) return;

                try {
                    const arrayBuffer = await file.arrayBuffer();
                    const uInt8Array = new Uint8Array(arrayBuffer);

                    const SQL = await initSqlJs({
                        locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
                    });
                    const db = new SQL.Database(uInt8Array);

                    const tableQuery = db.exec("SELECT name FROM sqlite_master WHERE type='table';");
                    const tables = tableQuery[0]?.values?.map(row => row[0]) || [];

                    if (tables.length === 0) {
                        alert('No tables found in the database.');
                        db.close();
                        return;
                    }

                    const tableName = tables[0];
                    const result = db.exec(`SELECT * FROM ${tableName}`);

                    if (!result[0]) {
                        alert('No data found in the table.');
                        db.close();
                        return;
                    }

                    const columns = result[0].columns;
                    const values = result[0].values;

                    const table = document.getElementById('dynamicTable');
                    const thead = table.querySelector('thead');
                    const tbody = table.querySelector('tbody');
                    thead.innerHTML = '';
                    tbody.innerHTML = '';

                    const headerRow = document.createElement('tr');
                    headerRow.innerHTML = '<th class="row-number"></th>';
                    columns.forEach((header, index) => {
                        const th = document.createElement('th');
                        th.contentEditable = true;
                        th.style.backgroundColor = "#0d8bf1";
                        th.style.fontWeight = "bold";
                        th.textContent = header?.toString() || `Feature ${index + 1}`;
                        headerRow.appendChild(th);
                    });
                    thead.appendChild(headerRow);

                    values.forEach((row, rowIndex) => {
                        const tr = document.createElement('tr');
                        tr.innerHTML = `<td class="row-number">${rowIndex + 1}</td>`;
                        row.forEach(cell => {
                            const td = document.createElement('td');
                            td.contentEditable = true;
                            td.textContent = cell?.toString() || '';
                            tr.appendChild(td);
                        });
                        tbody.appendChild(tr);
                    });

                    document.getElementById('importSection').style.display = 'none';
                    document.getElementById('dataframeSection').style.display = 'flex';
                    updateRowNumbers();
                    updateColumnSelect();
                    updateKnnSelects();
                    updateLrSelects();

                    db.close();

                } catch (error) {
                    alert('Error processing SQL file: ' + error.message);
                    console.error('SQL import error:', error);
                }
            };
            input.click();
        });

        function calculateMean(values) {
            if (values.length === 0) return 0;
            const sum = values.reduce((acc, val) => acc + val, 0);
            return sum / values.length;
        }

        function calculateMedian(values) {
            if (values.length === 0) return 0;
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 !== 0 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
        }

        function calculateMode(values) {
            const frequency = {};
            let maxFreq = 0;
            let modes = [];

            values.forEach(value => {
                frequency[value] = (frequency[value] || 0) + 1;
                if (frequency[value] > maxFreq) {
                    maxFreq = frequency[value];
                    modes = [value];
                } else if (frequency[value] === maxFreq) {
                    modes.push(value);
                }
            });

            return modes.length === values.length ? [] : modes;
        }

        function calculateStdDev(values, mean) {
            if (values.length <= 1) return 0;
            const currentMean = (mean === undefined) ? calculateMean(values) : mean;
            const variance = values.reduce((acc, val) => acc + Math.pow(val - currentMean, 2), 0) / (values.length - 1);
            return Math.sqrt(variance);
        }

        function updateRowNumbers() {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            rows.forEach((row, index) => {
                row.querySelector('.row-number').textContent = index + 1;
            });
        }

        function updateFeatureNames() {
            const headers = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');
            let featureCount = 1;

            headers.forEach((header) => {
                if (!header.textContent.trim() || /^Feature \d+$/.test(header.textContent)) {
                    header.textContent = `Feature ${featureCount}`;
                }
                featureCount++;
            });
        }

        function updateColumnSelect() {
            const allSelects = document.querySelectorAll('.column-select');
            const headerCells = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');

            allSelects.forEach(select => {
                const currentSelectedIndex = select.selectedIndex;
                select.innerHTML = '';

                if (headerCells.length === 0) return;

                headerCells.forEach((header, index) => {
                    const option = document.createElement('option');
                    option.value = index;
                    option.text = header.textContent || `Column ${index + 1}`;
                    select.appendChild(option);
                });

                if (currentSelectedIndex !== -1 && currentSelectedIndex < select.options.length) {
                    select.selectedIndex = currentSelectedIndex;
                } else if (select.options.length > 0) {
                    const isSecondCorrelationSelect = select.classList.contains('correlation-column-select') &&
                        select.parentElement.querySelector('label:first-of-type')?.textContent.includes('Column 1') &&
                        select.previousElementSibling?.textContent.includes('Column 2');

                    if (isSecondCorrelationSelect && select.options.length > 1) {
                        select.selectedIndex = 1;
                    } else {
                        select.selectedIndex = 0;
                    }
                }
            });
        }

        const projectTitle = document.querySelector('.project-title');

        projectTitle.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                projectTitle.blur();
            }
        });

        projectTitle.addEventListener('input', (e) => {
            localStorage.setItem('projectName', e.target.textContent);
        });

        document.addEventListener('DOMContentLoaded', () => {
            const savedName = localStorage.getItem('projectName');
            if (savedName) {
                projectTitle.textContent = savedName;
            }
        });

        let currentCleaningAction = null;

        document.getElementById('handlingMethod').addEventListener('change', function() {
            const imputationOptions = document.getElementById('imputationOptions');
            imputationOptions.style.display = this.value === 'impute' ? 'block' : 'none';
        });

        function showMissingValuesDialog() {
            document.getElementById('missingValuesBackdrop').style.display = 'block';
            document.getElementById('missingValuesDialog').style.display = 'block';
            populateColumnSelect('missingValuesColumn');
            const methodSelect = document.getElementById('handlingMethod');
            const imputationOptions = document.getElementById('imputationOptions');
            imputationOptions.style.display = methodSelect.value === 'impute' ? 'block' : 'none';
        }

        function showColumnActionDialog(title) {
            document.getElementById('columnActionBackdrop').style.display = 'block';
            document.getElementById('columnActionDialog').style.display = 'block';
            document.getElementById('columnActionTitle').textContent = title;
            populateColumnSelect('actionColumnSelect');
        }

        function showMultiplyColumnsDialog() {
            document.getElementById('multiplyColumnsBackdrop').style.display = 'block';
            document.getElementById('multiplyColumnsDialog').style.display = 'block';
            populateColumnSelect('multiplyColumn1');
            populateColumnSelect('multiplyColumn2');
        }

        function showAppendStringDialog() {
            document.getElementById('appendStringBackdrop').style.display = 'block';
            document.getElementById('appendStringDialog').style.display = 'block';
            populateColumnSelect('appendColumnSelect');
            document.getElementById('appendStringInput').value = '';
            document.getElementById('appendPosition').selectedIndex = 0;
        }

        function hideAllDialogs() {
            document.querySelectorAll('.dialog-backdrop').forEach(d => d.style.display = 'none');
            document.querySelectorAll('.cleaning-dialog').forEach(d => d.style.display = 'none');
        }

        function populateColumnSelect(selectId) {
            const select = document.getElementById(selectId);
            select.innerHTML = '';
            const headers = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');
            headers.forEach((header, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = header.textContent;
                select.appendChild(option);
            });
        }

        function handleMissingValues() {
    const colIndex = parseInt(document.getElementById('missingValuesColumn').value);
    const method = document.getElementById('handlingMethod').value;

    if (method === 'remove') {
        const rows = document.querySelectorAll('#dynamicTable tbody tr');
        rows.forEach(row => {
            const cell = row.cells[colIndex + 1];
            if (!cell.textContent.trim()) {
                row.remove();
            }
        });
        updateRowNumbers();
    } else {
        const imputationType = document.getElementById('imputationType').value;
        const rows = document.querySelectorAll('#dynamicTable tbody tr');
        let imputeValue = null;
        let previousValue = null;

        switch (imputationType) {
            case 'mean':
                const numericValuesMean = [];
                rows.forEach(row => {
                    const cell = row.cells[colIndex + 1];
                    const value = parseFloat(cell.textContent);
                    if (!isNaN(value)) {
                        numericValuesMean.push(value);
                    }
                });
                imputeValue = numericValuesMean.length > 0 ? calculateMean(numericValuesMean) : 0;
                break;
            case 'median':
                const numericValuesMedian = [];
                rows.forEach(row => {
                    const cell = row.cells[colIndex + 1];
                    const value = parseFloat(cell.textContent);
                    if (!isNaN(value)) {
                        numericValuesMedian.push(value);
                    }
                });
                imputeValue = numericValuesMedian.length > 0 ? calculateMedian(numericValuesMedian) : 0;
                break;
            case 'mode':
                const allValues = [];
                rows.forEach(row => {
                    const cell = row.cells[colIndex + 1];
                    const value = cell.textContent.trim();
                    if (value !== '') {
                        allValues.push(value);
                    }
                });
                const modes = calculateMode(allValues);
                imputeValue = modes.length > 0 ? modes[0] : 'N/A';
                break;
            case 'previous':
                // Handled in the loop below
                break;
        }

        rows.forEach(row => {
            const cell = row.cells[colIndex + 1];
            if (!cell.textContent.trim()) {
                if (imputationType === 'previous') {
                    if (previousValue !== null) {
                        cell.textContent = previousValue;
                    }
                } else {
                    cell.textContent = imputeValue;
                }
            } else {
                previousValue = cell.textContent.trim();
            }
        });
    }
    hideAllDialogs();
}

        function standardizeText(colIndex) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                cell.textContent = cell.textContent.trim().toLowerCase();
            });
        }

        function convertToNumeric(colIndex) {
    const rows = document.querySelectorAll('#dynamicTable tbody tr');
    let hasInvalid = false;

    rows.forEach(row => {
        const cell = row.cells[colIndex + 1];
        let original = cell.textContent.trim();

        // Skip empty cells
        if (original === '') return;

        // Remove surrounding single and double quotes
        original = original.replace(/^['"]|['"]$/g, '');

        // Skip cells already marked as invalid
        if (original.startsWith('INVALID: ')) return;

        const number = parseFloat(original);

        if (isNaN(number)) {
            cell.textContent = 'INVALID: ' + original;
            hasInvalid = true;
        } else {
            cell.textContent = number.toString();
        }
    });

    if (hasInvalid) {
        alert('Some values couldn\'t be converted. Invalid entries are marked with "INVALID: " prefix.');
    }
}

        function squareValues(colIndex) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            const headerRow = document.querySelector('#dynamicTable thead tr');
            const header = headerRow.cells[colIndex + 1].textContent;
            const newHeader = document.createElement('th');
            newHeader.contentEditable = true;
            newHeader.style.backgroundColor = '#0d8bf1';
            newHeader.style.fontWeight = 'bold';
            newHeader.textContent = `Square of ${header}`;
            headerRow.appendChild(newHeader);

            let hasInvalid = false;
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                const newCell = document.createElement('td');
                newCell.contentEditable = true;
                const value = parseFloat(cell.textContent.trim());
                if (!isNaN(value)) {
                    newCell.textContent = (value * value).toString();
                } else {
                    newCell.textContent = 'INVALID';
                    hasInvalid = true;
                }
                row.appendChild(newCell);
            });

            if (hasInvalid) {
                alert('Some values couldn\'t be squared. Invalid entries are marked with "INVALID".');
            }
            updateColumnSelect();
            updateKnnSelects();
            updateLrSelects();
        }

        function squareRoot(colIndex) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            const headerRow = document.querySelector('#dynamicTable thead tr');
            const header = headerRow.cells[colIndex + 1].textContent;
            const newHeader = document.createElement('th');
            newHeader.contentEditable = true;
            newHeader.style.backgroundColor = '#0d8bf1';
            newHeader.style.fontWeight = 'bold';
            newHeader.textContent = `Sqrt of ${header}`;
            headerRow.appendChild(newHeader);

            let hasInvalid = false;
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                const newCell = document.createElement('td');
                newCell.contentEditable = true;
                const value = parseFloat(cell.textContent.trim());
                if (!isNaN(value) && value >= 0) {
                    newCell.textContent = Math.sqrt(value).toString();
                } else {
                    newCell.textContent = 'INVALID';
                    hasInvalid = true;
                }
                row.appendChild(newCell);
            });

            if (hasInvalid) {
                alert('Some values couldn\'t be processed (negatives or non-numeric). Invalid entries are marked with "INVALID".');
            }
            updateColumnSelect();
            updateKnnSelects();
            updateLrSelects();
        }

        function capitalizeText(colIndex) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                const text = cell.textContent.trim();
                if (text) {
                    cell.textContent = text
                        .split(' ')
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
                        .join(' ');
                }
            });
        }

        function reverseText(colIndex) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                const text = cell.textContent.trim();
                if (text) {
                    cell.textContent = text.split('').reverse().join('');
                }
            });
        }

        function labelEncoding(colIndex) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            const headerRow = document.querySelector('#dynamicTable thead tr');
            const header = headerRow.cells[colIndex + 1].textContent;
            const newHeader = document.createElement('th');
            newHeader.contentEditable = true;
            newHeader.style.backgroundColor = '#0d8bf1';
            newHeader.style.fontWeight = 'bold';
            newHeader.textContent = `Encoded ${header}`;
            headerRow.appendChild(newHeader);

            const uniqueValues = new Set();
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                uniqueValues.add(cell.textContent.trim());
            });

            const labelMap = {};
            Array.from(uniqueValues).forEach((value, index) => {
                labelMap[value] = index;
            });

            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                const newCell = document.createElement('td');
                newCell.contentEditable = true;
                const value = cell.textContent.trim();
                newCell.textContent = labelMap[value].toString();
                row.appendChild(newCell);
            });

            updateColumnSelect();
            updateKnnSelects();
            updateLrSelects();
        }

        function appendString(colIndex, appendText, position) {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            rows.forEach(row => {
                const cell = row.cells[colIndex + 1];
                const text = cell.textContent.trim();
                if (text || appendText) {
                    cell.textContent = position === 'append' ? text + appendText : appendText + text;
                }
            });
        }

        function showRemovalFeedback(removedCount) {
            if (removedCount > 0) {
                alert(`${removedCount} duplicate rows were removed.`);
            } else {
                alert("No duplicate rows found.");
            }
        }

        function removeDuplicates() {
            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            const seen = new Set();
            let removedCount = 0;

            Array.from(rows).reverse().forEach(row => {
                const cells = Array.from(row.cells)
                    .slice(1)
                    .map(cell => cell.textContent.trim().toLowerCase());
                const key = cells.join('|');

                if (seen.has(key)) {
                    row.remove();
                    removedCount++;
                } else {
                    seen.add(key);
                }
            });

            updateRowNumbers();
            return removedCount;
        }

        function transposeTable() {
            const table = document.getElementById('dynamicTable');
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.rows);
            const headers = Array.from(thead.rows[0].cells).slice(1);

            const data = [
                headers.map(header => header.textContent),
                ...rows.map(row => Array.from(row.cells).slice(1).map(cell => cell.textContent))
            ];

            const transposedData = data[0].map((_, colIndex) => data.map(row => row[colIndex] || ''));

            thead.innerHTML = '';
            tbody.innerHTML = '';

            const newHeaderRow = document.createElement('tr');
            newHeaderRow.innerHTML = '<th class="row-number"></th>';

            if (transposedData.length > 0) {
                for (let i = 0; i < transposedData[0].length; i++) {
                    const th = document.createElement('th');
                    th.contentEditable = true;
                    th.style.backgroundColor = "#0d8bf1";
                    th.style.fontWeight = "bold";
                    th.textContent = transposedData[0][i] || `Feature ${i + 1}`;
                    newHeaderRow.appendChild(th);
                }
            }
            thead.appendChild(newHeaderRow);

            for (let i = 1; i < transposedData.length; i++) {
                const tr = document.createElement('tr');
                tr.innerHTML = `<td class="row-number">${i}</td>`;
                for (let j = 0; j < transposedData[i].length; j++) {
                    const td = document.createElement('td');
                    td.contentEditable = true;
                    td.textContent = transposedData[i][j] || '';
                    tr.appendChild(td);
                }
                tbody.appendChild(tr);
            }

            updateRowNumbers();
            updateColumnSelect();
            updateKnnSelects();
            updateLrSelects();
        }

        function multiplyColumns() {
            const colIndex1 = parseInt(document.getElementById('multiplyColumn1').value);
            const colIndex2 = parseInt(document.getElementById('multiplyColumn2').value);
            const headers = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');
            const colName1 = headers[colIndex1].textContent;
            const colName2 = headers[colIndex2].textContent;

            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            const products = [];

            for (let i = 0; i < rows.length; i++) {
                const cell1 = rows[i].cells[colIndex1 + 1];
                const cell2 = rows[i].cells[colIndex2 + 1];
                const val1 = parseFloat(cell1.textContent);
                const val2 = parseFloat(cell2.textContent);
                if (!isNaN(val1) && !isNaN(val2)) {
                    products.push(val1 * val2);
                } else {
                    products.push('NaN');
                }
            }

            const headerRow = document.querySelector('#dynamicTable thead tr');
            const newHeader = document.createElement('th');
            newHeader.contentEditable = true;
            newHeader.style.backgroundColor = "#0d8bf1";
            newHeader.style.fontWeight = "bold";
            newHeader.textContent = `Product of ${colName1} and ${colName2}`;
            headerRow.appendChild(newHeader);

            rows.forEach((row, index) => {
                const newCell = document.createElement('td');
                newCell.contentEditable = true;
                newCell.textContent = products[index];
                row.appendChild(newCell);
            });

            hideAllDialogs();
            updateColumnSelect();
            updateKnnSelects();
            updateLrSelects();
        }

        document.addEventListener('DOMContentLoaded', () => {
            const duplicateConfirmation = document.getElementById('duplicateConfirmation');
            const duplicateBackdrop = document.getElementById('duplicateBackdrop');

            document.getElementById('removeDuplicates').addEventListener('click', (e) => {
                e.preventDefault();
                duplicateConfirmation.style.display = 'block';
                duplicateBackdrop.style.display = 'block';
            });

            document.getElementById('confirmDuplicateBtn').addEventListener('click', () => {
                const removedCount = removeDuplicates();
                duplicateConfirmation.style.display = 'none';
                duplicateBackdrop.style.display = 'none';
                showRemovalFeedback(removedCount);
            });

            document.getElementById('cancelDuplicateBtn').addEventListener('click', () => {
                duplicateConfirmation.style.display = 'none';
                duplicateBackdrop.style.display = 'none';
            });

            duplicateBackdrop.addEventListener('click', () => {
                duplicateConfirmation.style.display = 'none';
                duplicateBackdrop.style.display = 'none';
            });

            document.getElementById('transposeOption').addEventListener('click', (e) => {
                e.preventDefault();
                transposeTable();
            });

            document.getElementById('multiplyColumnsOption').addEventListener('click', (e) => {
                e.preventDefault();
                showMultiplyColumnsDialog();
            });

            document.getElementById('squareValuesOption').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'square';
                showColumnActionDialog('Square Values');
            });

            document.getElementById('squareRootOption').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'sqrt';
                showColumnActionDialog('Square Root');
            });

            document.getElementById('capitalizeTextOption').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'capitalize';
                showColumnActionDialog('Capitalize Text');
            });

            document.getElementById('reverseTextOption').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'reverse';
                showColumnActionDialog('Reverse Text');
            });

            document.getElementById('labelEncodingOption').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'labelEncode';
                showColumnActionDialog('Label Encoding');
            });

            document.getElementById('appendStringOption').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'appendString';
                showAppendStringDialog();
            });

            document.getElementById('confirmMultiplyColumnsBtn').addEventListener('click', multiplyColumns);
            document.getElementById('cancelMultiplyColumnsBtn').addEventListener('click', hideAllDialogs);

            document.getElementById('confirmAppendStringBtn').addEventListener('click', () => {
                const colIndex = parseInt(document.getElementById('appendColumnSelect').value);
                const appendText = document.getElementById('appendStringInput').value;
                const position = document.getElementById('appendPosition').value;
                appendString(colIndex, appendText, position);
                hideAllDialogs();
            });

            document.getElementById('cancelAppendStringBtn').addEventListener('click', hideAllDialogs);

            document.getElementById('confirmColumnActionBtn').addEventListener('click', () => {
                const colIndex = parseInt(document.getElementById('actionColumnSelect').value);
                if (currentCleaningAction === 'standardize') {
                    standardizeText(colIndex);
                } else if (currentCleaningAction === 'convert') {
                    convertToNumeric(colIndex);
                } else if (currentCleaningAction === 'square') {
                    squareValues(colIndex);
                } else if (currentCleaningAction === 'sqrt') {
                    squareRoot(colIndex);
                } else if (currentCleaningAction === 'capitalize') {
                    capitalizeText(colIndex);
                } else if (currentCleaningAction === 'reverse') {
                    reverseText(colIndex);
                } else if (currentCleaningAction === 'labelEncode') {
                    labelEncoding(colIndex);
                }
                hideAllDialogs();
            });
            document.getElementById('cancelColumnActionBtn').addEventListener('click', hideAllDialogs);

            document.querySelectorAll('.dialog-backdrop').forEach(backdrop => {
                backdrop.addEventListener('click', hideAllDialogs);
            });

            const showDataFrameLink = document.getElementById('showDataFrameLink');
            const importSection = document.getElementById('importSection');
            const dataframeSection = document.getElementById('dataframeSection');
            const addRowButton = document.getElementById('addRow');
            const removeLastRowButton = document.getElementById('removeLastRow');
            const table = document.getElementById('dynamicTable');
            const tableHead = table.querySelector('thead');
            const tableBody = table.querySelector('tbody');
            const addColumnButton = document.getElementById('addColumn');
            const descriptiveStatsOption = document.getElementById('descriptiveStatsOption');
            const correlationAnalysisOption = document.getElementById('correlationAnalysisOption');
            const knnOption = document.getElementById('knnOption');
            const linearRegressionOption = document.getElementById('linearRegressionOption');
            const statsSectionsContainer = document.getElementById('stats-sections-container');
            const columnContextMenu = document.getElementById('column-context-menu');
            const removeColumnOption = document.getElementById('remove-column-option');
            const rowContextMenu = document.getElementById('row-context-menu');
            const removeRowOption = document.getElementById('remove-row-option');

            document.getElementById('handleMissingValues').addEventListener('click', (e) => {
                e.preventDefault();
                currentCleaningAction = 'missing';
                showMissingValuesDialog();
            });

            document.getElementById('confirmMissingValuesBtn').addEventListener('click', handleMissingValues);

            if (showDataFrameLink) {
                showDataFrameLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    importSection.style.display = 'none';
                    dataframeSection.style.display = 'flex';
                    dataframeSection.style.flexDirection = 'column';
                    dataframeSection.style.alignItems = 'center';
                });
            }

            addRowButton.addEventListener('click', () => {
                const row = tableBody.insertRow();
                const numCols = tableHead.rows[0]?.cells.length || 2;

                const rowNumberCell = row.insertCell(0);
                rowNumberCell.className = 'row-number';
                rowNumberCell.textContent = tableBody.rows.length;

                for (let i = 1; i < numCols; i++) {
                    const cell = row.insertCell(i);
                    cell.contentEditable = true;
                }
                updateRowNumbers();
            });

            removeLastRowButton.addEventListener('click', () => {
                if (tableBody.rows.length > 1) {
                    tableBody.deleteRow(-1);
                    updateRowNumbers();
                } else {
                    alert("Cannot remove the last data row.");
                }
            });

            addColumnButton.addEventListener('click', () => {
                const headerRow = tableHead.rows[0];
                const bodyRows = tableBody.rows;
                if (!headerRow) return;

                const newHeader = document.createElement("th");
                newHeader.contentEditable = true;
                newHeader.style.backgroundColor = "#0d8bf1";
                newHeader.style.fontWeight = "bold";

                const currentColumnCount = headerRow.cells.length - 1;
                newHeader.textContent = `Feature ${currentColumnCount + 1}`;

                headerRow.appendChild(newHeader);

                for (let i = 0; i < bodyRows.length; i++) {
                    const newCell = document.createElement("td");
                    newCell.contentEditable = true;
                    bodyRows[i].appendChild(newCell);
                }
                updateColumnSelect();
                updateKnnSelects();
                updateLrSelects();
            });

            tableHead.addEventListener('input', (e) => {
                if (e.target.tagName === 'TH' && !e.target.classList.contains('row-number')) {
                    if (!e.target.textContent.trim()) {
                        const currentColumnCount = document.querySelectorAll('#dynamicTable thead th:not(.row-number)').length;
                        e.target.textContent = `Feature ${currentColumnCount}`;
                    }
                }
            });

            tableBody.addEventListener('contextmenu', (e) => {
                const targetCell = e.target.closest('.row-number');
                if (targetCell) {
                    e.preventDefault();
                    rowToRemoveIndex = targetCell.parentNode.rowIndex;
                    rowContextMenu.style.top = `${e.pageY}px`;
                    rowContextMenu.style.left = `${e.pageX}px`;
                    rowContextMenu.style.display = 'block';
                }
            });

            removeRowOption.addEventListener('click', () => {
                if (rowToRemoveIndex > -1) {
                    tableBody.deleteRow(rowToRemoveIndex - 1);
                    updateRowNumbers();
                }
                rowContextMenu.style.display = 'none';
                rowToRemoveIndex = -1;
            });

            document.addEventListener('click', (e) => {
                if (!rowContextMenu.contains(e.target)) {
                    rowContextMenu.style.display = 'none';
                }
            });

            tableHead.addEventListener('contextmenu', (event) => {
                const targetHeader = event.target.closest('th');
                if (targetHeader && tableHead.contains(targetHeader) && !targetHeader.classList.contains('row-number')) {
                    event.preventDefault();
                    if (tableHead.rows[0].cells.length <= 2) {
                        alert("Cannot remove the last column.");
                        columnContextMenu.style.display = 'none';
                        return;
                    }
                    columnToRemoveIndex = targetHeader.cellIndex;
                    columnContextMenu.style.top = `${event.pageY}px`;
                    columnContextMenu.style.left = `${event.pageX}px`;
                    columnContextMenu.style.display = 'block';
                } else {
                    columnContextMenu.style.display = 'none';
                }
            });

            document.addEventListener('click', (event) => {
                if (!columnContextMenu.contains(event.target)) {
                    columnContextMenu.style.display = 'none';
                }
            });

            let columnToRemoveIndex = -1;
            let rowToRemoveIndex = -1;

            removeColumnOption.addEventListener('click', () => {
                if (columnToRemoveIndex > 0 && tableHead.rows[0]?.cells.length > 2) {
                    tableHead.rows[0].deleteCell(columnToRemoveIndex);
                    for (let i = 0; i < tableBody.rows.length; i++) {
                        tableBody.rows[i].deleteCell(columnToRemoveIndex);
                    }
                    updateColumnSelect();
                    updateFeatureNames();
                    updateKnnSelects();
                    updateLrSelects();
                }
                columnContextMenu.style.display = 'none';
                columnToRemoveIndex = -1;
            });

            correlationAnalysisOption.addEventListener('click', (e) => {
                e.preventDefault();
                const correlationSection = document.createElement('div');
                correlationSection.className = 'correlation-section';

                const label1 = document.createElement('label');
                label1.style.fontFamily = 'Open Sans';
                label1.textContent = 'Column 1:';
                const select1 = document.createElement('select');
                select1.className = 'column-select correlation-column-select';

                const label2 = document.createElement('label');
                label2.style.fontFamily = 'Open Sans';
                label2.textContent = 'Column 2:';
                const select2 = document.createElement('select');
                select2.className = 'column-select correlation-column-select';

                const calculateButton = document.createElement('button');
                calculateButton.textContent = 'Calculate Correlation';

                const correlationOutput = document.createElement('div');
                correlationOutput.className = 'correlation-output';
                correlationOutput.style.fontFamily = 'Open Sans';
                correlationOutput.style.fontSize = '1em';
                correlationOutput.style.marginTop = '5px';
                correlationOutput.style.width = '100%';

                const removeButton = document.createElement('button');
                removeButton.textContent = 'Remove';
                removeButton.className = 'remove-button';

                function populateCorrelationSelects(selectElement) {
                    const headerCells = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');
                    selectElement.innerHTML = '';
                    headerCells.forEach((header, index) => {
                        const option = document.createElement('option');
                        option.value = index;
                        option.text = header.textContent || `Column ${index + 1}`;
                        selectElement.appendChild(option);
                    });
                }

                populateCorrelationSelects(select1);
                populateCorrelationSelects(select2);

                if (select2.options.length > 1) {
                    select2.selectedIndex = 1;
                } else if (select2.options.length > 0) {
                    select2.selectedIndex = 0;
                }

                correlationSection.appendChild(label1);
                correlationSection.appendChild(select1);
                correlationSection.appendChild(label2);
                correlationSection.appendChild(select2);
                correlationSection.appendChild(calculateButton);
                correlationSection.appendChild(removeButton);
                correlationSection.appendChild(correlationOutput);
                statsSectionsContainer.appendChild(correlationSection);

                removeButton.addEventListener('click', () => {
                    correlationSection.remove();
                });

                calculateButton.addEventListener('click', () => {
                    const colIndex1 = parseInt(select1.value);
                    const colIndex2 = parseInt(select2.value);
                    const rows = tableBody.rows;
                    const values1 = [];
                    const values2 = [];

                    if (colIndex1 === colIndex2) {
                        correlationOutput.innerHTML = `<strong>Error:</strong> Please select two different columns.`;
                        return;
                    }

                    for (let i = 0; i < rows.length; i++) {
                        const cell1 = rows[i].cells[colIndex1 + 1];
                        const cell2 = rows[i].cells[colIndex2 + 1];
                        if (cell1 && cell2) {
                            const val1Text = cell1.innerText.trim();
                            const val2Text = cell2.innerText.trim();
                            if (val1Text !== '' && val2Text !== '') {
                                const val1 = parseFloat(val1Text);
                                const val2 = parseFloat(val2Text);
                                if (!isNaN(val1) && !isNaN(val2)) {
                                    values1.push(val1);
                                    values2.push(val2);
                                }
                            }
                        }
                    }

                    if (values1.length < 2) {
                        correlationOutput.innerHTML = `<strong>Error:</strong> Not enough valid numeric data pairs (found ${values1.length}). Need at least 2.`;
                        return;
                    }

                    const n = values1.length;
                    const mean1 = calculateMean(values1);
                    const mean2 = calculateMean(values2);
                    const stdDev1 = calculateStdDev(values1, mean1);
                    const stdDev2 = calculateStdDev(values2, mean2);

                    if (stdDev1 === 0 || stdDev2 === 0) {
                        correlationOutput.innerHTML = `<strong>Result:</strong> Correlation is undefined (one or both columns have zero standard deviation).`;
                        return;
                    }

                    let covarianceSum = 0;
                    for (let i = 0; i < n; i++) {
                        covarianceSum += (values1[i] - mean1) * (values2[i] - mean2);
                    }

                    const correlation = covarianceSum / ((n - 1) * stdDev1 * stdDev2);
                    const clampedCorrelation = Math.max(-1, Math.min(1, correlation));
                    correlationOutput.innerHTML = `<strong>Pearson Correlation:</strong> ${clampedCorrelation.toFixed(4)}`;
                });
            });

            descriptiveStatsOption.addEventListener('click', (e) => {
                e.preventDefault();
                const statsSection = document.createElement('div');
                statsSection.className = 'stats-section';

                const label = document.createElement('label');
                label.style.fontFamily = 'Open Sans';
                label.style.fontSize = '1em';
                label.textContent = 'Select a column:';

                const select = document.createElement('select');
                select.className = 'column-select';
                select.style.marginRight = '10px';

                const calculateButton = document.createElement('button');
                calculateButton.style.marginLeft = '10px';
                calculateButton.textContent = 'Calculate Stats';

                const statsOutput = document.createElement('div');
                statsOutput.className = 'stats-output';
                statsOutput.style.marginTop = '10px';
                statsOutput.style.fontFamily = 'Open Sans';
                statsOutput.style.fontSize = '1em';

                const removeButton = document.createElement('button');
                removeButton.textContent = 'Remove';
                removeButton.className = 'remove-button';

                removeButton.addEventListener('click', () => {
                    statsSection.remove();
                });

                const headerCells = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');
                select.innerHTML = '';
                for (let i = 0; i < headerCells.length; i++) {
                    const option = document.createElement('option');
                    option.value = i;
                    option.text = headerCells[i].textContent || `Column ${i + 1}`;
                    select.appendChild(option);
                }

                statsSection.appendChild(label);
                statsSection.appendChild(select);
                statsSection.appendChild(calculateButton);
                statsSection.appendChild(removeButton);
                statsSection.appendChild(statsOutput);
                statsSectionsContainer.appendChild(statsSection);

                calculateButton.addEventListener('click', () => {
                    const columnIndex = parseInt(select.value);
                    const rows = tableBody.rows;
                    const values = [];
                    for (let i = 0; i < rows.length; i++) {
                        const cell = rows[i].cells[columnIndex + 1];
                        if (cell) {
                            const valueText = cell.innerText.trim();
                            if (valueText !== '') {
                                const value = parseFloat(valueText);
                                if (!isNaN(value)) {
                                    values.push(value);
                                }
                            }
                        }
                    }

                    if (values.length === 0) {
                        statsOutput.innerHTML = 'No numeric data in this column.';
                        return;
                    }

                    const sum = values.reduce((a, b) => a + b, 0);
                    const avg = sum / values.length;
                    const min = Math.min(...values);
                    const max = Math.max(...values);
                    const sorted = [...values].sort((a, b) => a - b);
                    const mid = Math.floor(sorted.length / 2);
                    const median = sorted.length % 2 === 0 ? (sorted[mid - 1] + sorted[mid]) / 2 : sorted[mid];
                    const frequency = {};
                    let maxFreq = 0;
                    let mode = [];
                    values.forEach(value => {
                        frequency[value] = (frequency[value] || 0) + 1;
                        if (frequency[value] > maxFreq) {
                            maxFreq = frequency[value];
                        }
                    });

                    const allSameFrequency = Object.values(frequency).every(freq => freq === maxFreq);
                    if (maxFreq === 1 || (allSameFrequency && Object.keys(frequency).length > 1)) {
                        mode = ["No mode"];
                    } else {
                        for (const key in frequency) {
                            if (frequency[key] === maxFreq) {
                                mode.push(Number(key));
                            }
                        }
                    }

                    const variance = values.reduce((acc, val) => acc + Math.pow(val - avg, 2), 0) / values.length;
                    const stdDev = Math.sqrt(variance);
                    statsOutput.innerHTML = `
                        <strong>Count:</strong> ${values.length}<br>
                        <strong>Sum:</strong> ${sum.toFixed(2)}<br>
                        <strong>Average:</strong> ${avg.toFixed(2)}<br>
                        <strong>Median:</strong> ${median.toFixed(2)}<br>
                        <strong>Mode:</strong> ${mode.join(', ')}<br>
                        <strong>Min:</strong> ${min}<br>
                        <strong>Max:</strong> ${max}<br>
                        <strong>Variance:</strong> ${variance.toFixed(2)}<br>
                        <strong>Standard Deviation:</strong> ${stdDev.toFixed(2)}`;
                });
            });

            knnOption.addEventListener('click', (e) => {
                e.preventDefault();
                const knnSection = createKnnSection();
                statsSectionsContainer.appendChild(knnSection);
            });

            linearRegressionOption.addEventListener('click', (e) => {
                e.preventDefault();
                const lrSection = createLinearRegressionSection();
                statsSectionsContainer.appendChild(lrSection);
            });

            table.addEventListener('keydown', function(event) {
                if (event.key === 'Enter') {
                    event.preventDefault();
                    const activeElement = document.activeElement;
                    if (activeElement.tagName === 'TD' && activeElement.contentEditable === 'true') {
                        const currentRow = activeElement.parentNode;
                        const currentCellIndex = activeElement.cellIndex;
                        const nextCellIndex = currentCellIndex + 1;
                        let nextCell = currentRow.cells[nextCellIndex];
                        if (nextCell && nextCell.contentEditable === 'true') {
                            nextCell.focus();
                        } else {
                            const nextRow = currentRow.nextElementSibling;
                            if (nextRow) {
                                let firstEditableCellInNextRow = null;
                                for (let i = 0; i < nextRow.cells.length; i++) {
                                    if (nextRow.cells[i].contentEditable === 'true') {
                                        firstEditableCellInNextRow = nextRow.cells[i];
                                        break;
                                    }
                                }
                                if (firstEditableCellInNextRow) {
                                    firstEditableCellInNextRow.focus();
                                } else {
                                    activeElement.blur();
                                }
                            } else {
                                activeElement.blur();
                            }
                        }
                    } else if (activeElement.tagName === 'TH' && activeElement.contentEditable === 'true') {
                        if (tableBody.rows.length > 0 && tableBody.rows[0].cells.length > 1 && tableBody.rows[0].cells[1].contentEditable === 'true') {
                            tableBody.rows[0].cells[1].focus();
                        } else {
                            activeElement.blur();
                        }
                    }
                }
            });

        });

        class StandardScaler {
            fitTransform(data) {
                this.means = [];
                this.stds = [];

                if (data.length === 0) return [];

                const numFeatures = data[0].length;
                for (let i = 0; i < numFeatures; i++) {
                    const featureValues = data.map(row => row[i]);
                    const mean = featureValues.reduce((a, b) => a + b, 0) / featureValues.length;
                    const std = Math.sqrt(featureValues.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / featureValues.length);

                    this.means.push(mean);
                    this.stds.push(std || 1);
                }

                return this.transform(data);
            }

            transform(data) {
                return data.map(row =>
                    row.map((val, i) =>
                        (val - this.means[i]) / this.stds[i]
                    )
                );
            }
        }

        class KNeighborsClassifier {
            constructor(k = 5) {
                this.k = k;
            }

            fit(X, y) {
                this.X_train = X;
                this.y_train = y;
            }

            predict(X_test) {
                return X_test.map(testPoint => {
                    const distances = this.X_train.map((trainPoint, i) => ({
                        label: this.y_train[i],
                        distance: Math.sqrt(
                            trainPoint.reduce((sum, val, j) =>
                                sum + Math.pow(val - testPoint[j], 2), 0)
                        )
                    }));

                    const nearest = distances
                        .sort((a, b) => a.distance - b.distance)
                        .slice(0, this.k);

                    const votes = {};
                    nearest.forEach(n => {
                        votes[n.label] = (votes[n.label] || 0) + 1;
                    });

                    return Object.entries(votes).sort((a, b) => b[1] - a[1])[0][0];
                });
            }
        }

        function createKnnSection() {
            const section = document.createElement('div');
            section.className = 'knn-section';

            const title = document.createElement('h3');
            title.textContent = 'KNN Prediction';
            section.appendChild(title);

            const controls = document.createElement('div');
            controls.className = 'knn-controls';

            const featuresContainer = document.createElement('div');
            featuresContainer.className = 'knn-select-container';
            const featuresLabel = document.createElement('label');
            featuresLabel.textContent = 'Features (Select Multiple):';
            const featuresSelect = document.createElement('select');
            featuresSelect.className = 'knn-features';
            featuresSelect.multiple = true;
            featuresSelect.style.width = '200px';
            featuresSelect.style.height = '100px';
            featuresContainer.appendChild(featuresLabel);
            featuresContainer.appendChild(featuresSelect);
            controls.appendChild(featuresContainer);

            const targetContainer = document.createElement('div');
            targetContainer.className = 'knn-select-container';
            const targetLabel = document.createElement('label');
            targetLabel.textContent = 'Target:';
            const targetSelect = document.createElement('select');
            targetSelect.className = 'knn-target';
            targetSelect.style.width = '200px';
            targetContainer.appendChild(targetLabel);
            targetContainer.appendChild(targetSelect);
            controls.appendChild(targetContainer);

            const paramsContainer = document.createElement('div');
            paramsContainer.className = 'knn-params';
            const kLabel = document.createElement('label');
            kLabel.textContent = 'Neighbors (K):';
            const kInput = document.createElement('input');
            kInput.type = 'number';
            kInput.className = 'k-value';
            kInput.min = '1';
            kInput.value = '5';
            kInput.style.width = '50px';
            paramsContainer.appendChild(kLabel);
            paramsContainer.appendChild(kInput);
            controls.appendChild(paramsContainer);

            section.appendChild(controls);

            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'knn-buttons';
            const makePredictionButton = document.createElement('button');
            makePredictionButton.className = 'make-prediction';
            makePredictionButton.textContent = 'Make Prediction';
            const resetButton = document.createElement('button');
            resetButton.className = 'reset-knn';
            resetButton.textContent = 'Reset';
            resetButton.style.backgroundColor = '#f44336';
            buttonsContainer.appendChild(makePredictionButton);
            buttonsContainer.appendChild(resetButton);
            section.appendChild(buttonsContainer);

            const resultsDiv = document.createElement('div');
            resultsDiv.className = 'knn-results';
            section.appendChild(resultsDiv);

            const removeButton = document.createElement('button');
            removeButton.textContent = 'Remove';
            removeButton.className = 'remove-button';
            removeButton.addEventListener('click', () => {
                section.remove();
            });
            section.appendChild(removeButton);

            populateKnnSelects(section);

            makePredictionButton.addEventListener('click', () => {
                trainAndPredict(section);
            });

            resetButton.addEventListener('click', () => {
                resetKnn(section);
            });

            return section;
        }

        function populateKnnSelects(section) {
            const featuresSelect = section.querySelector('.knn-features');
            const targetSelect = section.querySelector('.knn-target');
            const headerCells = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');

            featuresSelect.innerHTML = '';
            targetSelect.innerHTML = '';

            headerCells.forEach((header, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.text = header.textContent || `Column ${index + 1}`;
                featuresSelect.appendChild(option.cloneNode(true));
                targetSelect.appendChild(option);
            });
        }

        function updateKnnSelects() {
            const knnSections = document.querySelectorAll('.knn-section');
            knnSections.forEach(section => {
                populateKnnSelects(section);
            });
        }

        function trainAndPredict(section) {
            const featuresSelect = section.querySelector('.knn-features');
            const selectedFeatures = Array.from(featuresSelect.selectedOptions).map(opt => parseInt(opt.value));
            const targetSelect = section.querySelector('.knn-target');
            const selectedTarget = parseInt(targetSelect.value);
            const kInput = section.querySelector('.k-value');
            const kValue = parseInt(kInput.value);

            if (selectedFeatures.length === 0) {
                section.querySelector('.knn-results').innerHTML = "<strong>Error:</strong> Please select at least one feature";
                return;
            }

            const X_train = [], y_train = [];
            const X_all = [];
            const validRowIndices = [];

            const rows = document.querySelectorAll('#dynamicTable tbody tr');

            for (let i = 0; i < rows.length; i++) {
                const featureValues = [];
                let hasEmpty = false;

                for (const featureIndex of selectedFeatures) {
                    const cell = rows[i].cells[featureIndex + 1];
                    const valueText = cell?.innerText.trim();
                    if (!cell || valueText === '' || isNaN(parseFloat(valueText))) {
                        hasEmpty = true;
                        break;
                    }
                    featureValues.push(parseFloat(valueText));
                }

                if (!hasEmpty) {
                    const targetCell = rows[i].cells[selectedTarget + 1];
                    const targetValue = targetCell ? targetCell.innerText.trim() : '';

                    if (targetValue !== '') {
                        X_train.push(featureValues);
                        y_train.push(targetValue);
                    }

                    X_all.push(featureValues);
                    validRowIndices.push(i);
                }
            }

            if (X_train.length < kValue || X_train.length === 0) {
                section.querySelector('.knn-results').innerHTML = `<strong>Error:</strong> Not enough valid training data (found ${X_train.length} rows, need at least ${kValue}).`;
                return;
            }

            if (X_all.length === 0) {
                section.querySelector('.knn-results').innerHTML = `<strong>Error:</strong> No rows found with valid features to predict.`;
                return;
            }

            const scaler = new StandardScaler();
            const X_train_scaled = scaler.fitTransform(X_train);
            const X_all_scaled = scaler.transform(X_all);

            const knn = new KNeighborsClassifier(kValue);
            knn.fit(X_train_scaled, y_train);

            const predictions = knn.predict(X_all_scaled);

            const headerRow = document.querySelector('#dynamicTable thead tr');
            const newHeader = document.createElement('th');
            newHeader.contentEditable = true;
            newHeader.style.backgroundColor = '#0d8bf1';
            newHeader.style.fontWeight = 'bold';
            newHeader.textContent = 'KNN Prediction';
            headerRow.appendChild(newHeader);

            rows.forEach((row, index) => {
                const newCell = document.createElement('td');
                newCell.contentEditable = true;
                const predIndex = validRowIndices.indexOf(index);
                newCell.textContent = predIndex !== -1 ? predictions[predIndex] : '';
                row.appendChild(newCell);
            });

            section.querySelector('.knn-results').innerHTML = `<strong>Success:</strong> Predictions added for all valid rows.`;
            updateColumnSelect();
            updateKnnSelects();
            updateLrSelects();
        }

        function resetKnn(section) {
            const featuresSelect = section.querySelector('.knn-features');
            const targetSelect = section.querySelector('.knn-target');
            const kInput = section.querySelector('.k-value');
            const resultsDiv = section.querySelector('.knn-results');

            featuresSelect.selectedIndex = -1;
            targetSelect.selectedIndex = 0;
            kInput.value = '5';
            resultsDiv.innerHTML = '';
        }

        // Linear Regression Implementation
        function trainLinearRegression(X, y, options = {}) {
            const learningRate = 0.01;
            const iterations = 1000;
            const regularization = options.regularization || 'none';
            const alpha = options.alpha || 0;
            let degree = options.degree || 1;

            const scaler = new StandardScaler();
            let X_transformed = scaler.fitTransform(X);

            if (degree > 1) {
                if (degree > 2) degree = 2;
                const newX = [];
                for (let i = 0; i < X_transformed.length; i++) {
                    const row = X_transformed[i];
                    const newRow = [...row];
                    for (let j = 0; j < row.length; j++) {
                        for (let k = j; k < row.length; k++) {
                            newRow.push(row[j] * row[k]);
                        }
                    }
                    newX.push(newRow);
                }
                X_transformed = newX;
            }

            X_transformed = X_transformed.map(row => [1, ...row]);
            let coef = new Array(X_transformed[0].length).fill(0);

            for (let iter = 0; iter < iterations; iter++) {
                const predictions = X_transformed.map(row => 
                    row.reduce((sum, val, j) => sum + val * coef[j], 0)
                );
                const errors = predictions.map((p, i) => p - y[i]);
                const m = X_transformed.length;

                const gradients = X_transformed[0].map((_, j) => {
                    let grad = (1 / m) * X_transformed.reduce((sum, row, i) => 
                        sum + row[j] * errors[i], 0
                    );
                    if (regularization === 'l2' && j > 0) {
                        grad += (alpha / m) * coef[j];
                    } else if (regularization === 'l1' && j > 0) {
                        grad += (alpha / m) * Math.sign(coef[j]);
                    }
                    return grad;
                });

                coef = coef.map((c, j) => c - learningRate * gradients[j]);
            }

            return {
                scaler: scaler,
                coef: coef,
                degree: degree,
                predict: function(X_pred) {
                    let X_pred_transformed = this.scaler.transform(X_pred);
                    if (this.degree > 1) {
                        const newX = [];
                        for (let i = 0; i < X_pred_transformed.length; i++) {
                            const row = X_pred_transformed[i];
                            const newRow = [...row];
                            for (let j = 0; j < row.length; j++) {
                                for (let k = j; k < row.length; k++) {
                                    newRow.push(row[j] * row[k]);
                                }
                            }
                            newX.push(newRow);
                        }
                        X_pred_transformed = newX;
                    }
                    X_pred_transformed = X_pred_transformed.map(row => [1, ...row]);
                    return X_pred_transformed.map(row => 
                        row.reduce((sum, val, j) => sum + val * this.coef[j], 0)
                    );
                }
            };
        }

        function createLinearRegressionSection() {
            const section = document.createElement('div');
            section.className = 'lr-section';

            const title = document.createElement('h3');
            title.textContent = 'Linear Regression';
            section.appendChild(title);

            const controls = document.createElement('div');
            controls.className = 'lr-controls';

            const featuresContainer = document.createElement('div');
            featuresContainer.className = 'lr-select-container';
            const featuresLabel = document.createElement('label');
            featuresLabel.textContent = 'Features (Select Multiple):';
            const featuresSelect = document.createElement('select');
            featuresSelect.className = 'lr-features';
            featuresSelect.multiple = true;
            featuresSelect.style.width = '200px';
            featuresSelect.style.height = '100px';
            featuresContainer.appendChild(featuresLabel);
            featuresContainer.appendChild(featuresSelect);
            controls.appendChild(featuresContainer);

            const targetContainer = document.createElement('div');
            targetContainer.className = 'lr-select-container';
            const targetLabel = document.createElement('label');
            targetLabel.textContent = 'Target:';
            const targetSelect = document.createElement('select');
            targetSelect.className = 'lr-target';
            targetSelect.style.width = '200px';
            targetContainer.appendChild(targetLabel);
            targetContainer.appendChild(targetSelect);
            controls.appendChild(targetContainer);

            const advancedButton = document.createElement('button');
            advancedButton.textContent = 'View Advanced Options';
            controls.appendChild(advancedButton);

            const advancedOptions = document.createElement('div');
            advancedOptions.className = 'lr-advanced-options';

            const regTypeLabel = document.createElement('label');
            regTypeLabel.textContent = 'Regularization Type:';
            const regTypeSelect = document.createElement('select');
            regTypeSelect.innerHTML = `
                <option value="none">None (Basic)</option>
                <option value="l1">Lasso (L1)</option>
                <option value="l2">Ridge (L2)</option>
            `;
            advancedOptions.appendChild(regTypeLabel);
            advancedOptions.appendChild(regTypeSelect);

            const alphaContainer = document.createElement('div');
            alphaContainer.className = 'alpha-container';
            alphaContainer.style.display = 'none';
            const alphaLabel = document.createElement('label');
            alphaLabel.textContent = 'Alpha (Regularization Strength):';
            const alphaInput = document.createElement('input');
            alphaInput.type = 'number';
            alphaInput.value = '0.1';
            alphaInput.step = '0.01';
            alphaInput.min = '0';
            alphaContainer.appendChild(alphaLabel);
            alphaContainer.appendChild(alphaInput);
            advancedOptions.appendChild(alphaContainer);

            const polyContainer = document.createElement('div');
            polyContainer.className = 'poly-container';
            const polyLabel = document.createElement('label');
            polyLabel.textContent = 'Polynomial Degree (1 for none):';
            const polyInput = document.createElement('input');
            polyInput.type = 'number';
            polyInput.value = '1';
            polyInput.min = '1';
            polyInput.max = '2';
            polyContainer.appendChild(polyLabel);
            polyContainer.appendChild(polyInput);
            advancedOptions.appendChild(polyContainer);

            const optimizeButton = document.createElement('button');
            optimizeButton.textContent = 'Optimize Model';
            advancedOptions.appendChild(optimizeButton);

            controls.appendChild(advancedOptions);
            section.appendChild(controls);

            const buttonsContainer = document.createElement('div');
            buttonsContainer.className = 'lr-buttons';
            const predictButton = document.createElement('button');
            predictButton.textContent = 'Make Prediction';
            const resetButton = document.createElement('button');
            resetButton.textContent = 'Reset';
            resetButton.style.backgroundColor = '#f44336';
            buttonsContainer.appendChild(predictButton);
            buttonsContainer.appendChild(resetButton);
            section.appendChild(buttonsContainer);

            const resultsDiv = document.createElement('div');
            resultsDiv.className = 'lr-results';
            section.appendChild(resultsDiv);

            const removeButton = document.createElement('button');
            removeButton.textContent = 'Remove';
            removeButton.className = 'remove-button';
            removeButton.addEventListener('click', () => {
                section.remove();
            });
            section.appendChild(removeButton);

            populateLrSelects(section);

            advancedButton.addEventListener('click', () => {
                advancedOptions.style.display = advancedOptions.style.display === 'none' ? 'flex' : 'none';
            });

            regTypeSelect.addEventListener('change', () => {
                alphaContainer.style.display = regTypeSelect.value === 'none' ? 'none' : 'block';
            });

            predictButton.addEventListener('click', () => {
                trainAndPredictLr(section);
            });

            optimizeButton.addEventListener('click', () => {
                optimizeModelLr(section);
            });

            resetButton.addEventListener('click', () => {
                resetLr(section);
            });

            return section;
        }

        function populateLrSelects(section) {
            const featuresSelect = section.querySelector('.lr-features');
            const targetSelect = section.querySelector('.lr-target');
            const headerCells = document.querySelectorAll('#dynamicTable thead th:not(.row-number)');

            featuresSelect.innerHTML = '';
            targetSelect.innerHTML = '';

            headerCells.forEach((header, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.text = header.textContent || `Column ${index + 1}`;
                featuresSelect.appendChild(option.cloneNode(true));
                targetSelect.appendChild(option);
            });
        }

        function updateLrSelects() {
            const lrSections = document.querySelectorAll('.lr-section');
            lrSections.forEach(section => {
                populateLrSelects(section);
            });
        }

        function trainAndPredictLr(section) {
            const featuresSelect = section.querySelector('.lr-features');
            const selectedFeatures = Array.from(featuresSelect.selectedOptions).map(opt => parseInt(opt.value));
            const targetSelect = section.querySelector('.lr-target');
            const selectedTarget = parseInt(targetSelect.value);
            const regTypeSelect = section.querySelector('.lr-advanced-options select');
            const alphaInput = section.querySelector('.alpha-container input[type="number"]');
            const polyInput = section.querySelector('.poly-container input[type="number"]');
            const resultsDiv = section.querySelector('.lr-results');

            if (selectedFeatures.length === 0) {
                resultsDiv.innerHTML = "<strong>Error:</strong> Please select at least one feature.";
                return;
            }

            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            const X_train = [], y_train = [];
            const X_all = [];
            const validRowIndices = [];

            for (let i = 0; i < rows.length; i++) {
                const featureValues = [];
                let hasEmptyFeature = false;

                for (const featureIndex of selectedFeatures) {
                    const cell = rows[i].cells[featureIndex + 1];
                    const valueText = cell?.innerText.trim() || '';
                    const value = parseFloat(valueText);
                    if (valueText === '' || isNaN(value)) {
                        hasEmptyFeature = true;
                        break;
                    }
                    featureValues.push(value);
                }

                if (!hasEmptyFeature) {
                    const targetCell = rows[i].cells[selectedTarget + 1];
                    const targetValueText = targetCell?.innerText.trim() || '';
                    const targetValue = parseFloat(targetValueText);

                    if (targetValueText !== '' && !isNaN(targetValue)) {
                        X_train.push(featureValues);
                        y_train.push(targetValue);
                    }
                    X_all.push(featureValues);
                    validRowIndices.push(i);
                }
            }

            if (X_train.length === 0 || y_train.length === 0) {
                resultsDiv.innerHTML = "<strong>Error:</strong> No valid training data found.";
                return;
            }

            const options = {
                regularization: regTypeSelect.value,
                alpha: alphaInput ? parseFloat(alphaInput.value) : 0,
                degree: polyInput ? parseInt(polyInput.value) : 1
            };

            const model = trainLinearRegression(X_train, y_train, options);
            const predictions = model.predict(X_all);

            const headerRow = document.querySelector('#dynamicTable thead tr');
            const newHeader = document.createElement('th');
            newHeader.contentEditable = true;
            newHeader.style.backgroundColor = '#0d8bf1';
            newHeader.style.fontWeight = 'bold';
            newHeader.textContent = 'LR Prediction';
            headerRow.appendChild(newHeader);

            rows.forEach((row, index) => {
                const newCell = document.createElement('td');
                newCell.contentEditable = true;
                const predIndex = validRowIndices.indexOf(index);
                newCell.textContent = predIndex !== -1 ? predictions[predIndex].toFixed(2) : '';
                row.appendChild(newCell);
            });

            resultsDiv.innerHTML = `<strong>Success:</strong> Predictions added to table.`;
            updateColumnSelect();
            updateKnnSelects();
            updateLrSelects();
        }

        function optimizeModelLr(section) {
            const featuresSelect = section.querySelector('.lr-features');
            const selectedFeatures = Array.from(featuresSelect.selectedOptions).map(opt => parseInt(opt.value));
            const targetSelect = section.querySelector('.lr-target');
            const selectedTarget = parseInt(targetSelect.value);
            const resultsDiv = section.querySelector('.lr-results');

            if (selectedFeatures.length === 0) {
                resultsDiv.innerHTML = "<strong>Error:</strong> Please select at least one feature.";
                return;
            }

            const rows = document.querySelectorAll('#dynamicTable tbody tr');
            const X = [], y = [];

            for (let i = 0; i < rows.length; i++) {
                const featureValues = [];
                let hasEmpty = false;

                for (const featureIndex of selectedFeatures) {
                    const cell = rows[i].cells[featureIndex + 1];
                    const valueText = cell?.innerText.trim();
                    if (!cell || valueText === '' || isNaN(parseFloat(valueText))) {
                        hasEmpty = true;
                        break;
                    }
                    featureValues.push(parseFloat(valueText));
                }

                if (!hasEmpty) {
                    const targetCell = rows[i].cells[selectedTarget + 1];
                    const targetValueText = targetCell?.innerText.trim();
                    const targetValue = targetValueText ? parseFloat(targetValueText) : NaN;
                    if (!isNaN(targetValue)) {
                        X.push(featureValues);
                        y.push(targetValue);
                    }
                }
            }

            if (X.length < 5) {
                resultsDiv.innerHTML = `<strong>Error:</strong> Not enough data for optimization (need at least 5 rows, found ${X.length}).`;
                return;
            }

            const trainSize = Math.floor(X.length * 0.8);
            const X_train = X.slice(0, trainSize);
            const y_train = y.slice(0, trainSize);
            const X_test = X.slice(trainSize);
            const y_test = y.slice(trainSize);

            const hyperparams = [
                { regularization: 'none', alpha: 0, degree: 1 },
                { regularization: 'l1', alpha: 0.01, degree: 1 },
                { regularization: 'l1', alpha: 0.1, degree: 1 },
                { regularization: 'l1', alpha: 1, degree: 1 },
                { regularization: 'l2', alpha: 0.01, degree: 1 },
                { regularization: 'l2', alpha: 0.1, degree: 1 },
                { regularization: 'l2', alpha: 1, degree: 1 },
                { regularization: 'none', alpha: 0, degree: 2 },
                { regularization: 'l1', alpha: 0.01, degree: 2 },
                { regularization: 'l1', alpha: 0.1, degree: 2 },
                { regularization: 'l1', alpha: 1, degree: 2 },
                { regularization: 'l2', alpha: 0.01, degree: 2 },
                { regularization: 'l2', alpha: 0.1, degree: 2 },
                { regularization: 'l2', alpha: 1, degree: 2 },
            ];

            let bestMSE = Infinity;
            let bestParams = null;

            for (const params of hyperparams) {
                const model = trainLinearRegression(X_train, y_train, params);
                const predictions = model.predict(X_test);
                const mse = predictions.reduce((sum, p, i) => sum + Math.pow(p - y_test[i], 2), 0) / y_test.length;
                if (mse < bestMSE) {
                    bestMSE = mse;
                    bestParams = params;
                }
            }

            const regTypeSelect = section.querySelector('.lr-advanced-options select');
            const alphaInput = section.querySelector('.alpha-container input[type="number"]');
            const polyInput = section.querySelector('.poly-container input[type="number"]');

            regTypeSelect.value = bestParams.regularization;
            regTypeSelect.dispatchEvent(new Event('change'));
            alphaInput.value = bestParams.alpha;
            polyInput.value = bestParams.degree;

            resultsDiv.innerHTML = `<strong>Best Parameters Set:</strong> Regularization: ${bestParams.regularization}, Alpha: ${bestParams.alpha}, Degree: ${bestParams.degree}. Click 'Make Prediction' to use them.`;
        }

        function resetLr(section) {
            const featuresSelect = section.querySelector('.lr-features');
            const targetSelect = section.querySelector('.lr-target');
            const regTypeSelect = section.querySelector('.lr-advanced-options select');
            const alphaInput = section.querySelector('.alpha-container input[type="number"]');
            const polyInput = section.querySelector('.poly-container input[type="number"]');
            const resultsDiv = section.querySelector('.lr-results');
            const advancedOptions = section.querySelector('.lr-advanced-options');

            featuresSelect.selectedIndex = -1;
            targetSelect.selectedIndex = 0;
            regTypeSelect.selectedIndex = 0;
            alphaInput.value = '0.1';
            polyInput.value = '1';
            advancedOptions.style.display = 'none';
            resultsDiv.innerHTML = '';
        }

        document.getElementById('standardizeText').addEventListener('click', (e) => {
            e.preventDefault();
            currentCleaningAction = 'standardize';
            showColumnActionDialog('Standardize Text');
        });

        document.getElementById('convertToNumeric').addEventListener('click', (e) => {
            e.preventDefault();
            currentCleaningAction = 'convert';
            showColumnActionDialog('Convert to Numeric');
        });

        document.getElementById('cancelMissingValuesBtn').addEventListener('click', hideAllDialogs);

         // K-means section
document.getElementById("kmeansOption").addEventListener("click", (e) => {
    e.preventDefault();

    const hasData = document.querySelector("#dynamicTable thead th:not(.row-number)");
    if (!hasData) {
        alert("Please import or create a DataFrame first.");
        return;
    }

    const section = document.createElement("div");
    section.className = "stats-section";

    const title = document.createElement("h2");
    title.textContent = "K-Means Clustering";

    const kLabel = document.createElement("label");
    kLabel.textContent = "Number of Clusters (K):";
    const kInput = document.createElement("input");
    kInput.type = "number";
    kInput.min = 1;
    kInput.value = 2;
    kInput.id = "kmeans-k";

    const featureLabel = document.createElement("label");
    featureLabel.textContent = "Select Features:";
    const checkboxContainer = document.createElement("div");
    checkboxContainer.id = "kmeans-feature-checkboxes";
    checkboxContainer.style.maxHeight = "150px";
    checkboxContainer.style.overflowY = "auto";
    checkboxContainer.style.border = "1px solid #ccc";
    checkboxContainer.style.padding = "5px";

    const resultBox = document.createElement("div");
    resultBox.id = "kmeans-results";
    resultBox.className = "results-box";

    const runButton = document.createElement("button");
    runButton.textContent = "Run";
    runButton.style.backgroundColor = "#2196f3";
    runButton.style.color = "white";
    runButton.style.padding = "8px 16px";

    const clearButton = document.createElement("button");
    clearButton.textContent = "Rest";
    clearButton.style.backgroundColor = "red";
    clearButton.style.color = "white";
    clearButton.style.marginLeft = "10px";
    clearButton.style.padding = "8px 16px";

    const removeButton = document.createElement("button");
    removeButton.textContent = "Remove";
    removeButton.style.backgroundColor = "red";
    removeButton.className = "remove-button";
    removeButton.style.marginLeft = "10px";
    removeButton.style.padding = "8px 16px";

    section.appendChild(title);

    const kContainer = document.createElement("div");
    kContainer.style.marginBottom = "15px";
    kContainer.appendChild(kLabel);
    kContainer.appendChild(kInput);

    const featureContainer = document.createElement("div");
    featureContainer.style.marginBottom = "15px";
    featureContainer.appendChild(featureLabel);
    featureContainer.appendChild(checkboxContainer);
    
    section.appendChild(kContainer);
    section.appendChild(featureContainer);
    section.appendChild(runButton);
    section.appendChild(clearButton);
    section.appendChild(removeButton);
    section.appendChild(resultBox);

    document.getElementById("stats-sections-container").appendChild(section);

    populateKMeansColumnOptions();

    runButton.addEventListener("click", () => {
        const k = parseInt(kInput.value);
        const selectedIndices = Array.from(
            checkboxContainer.querySelectorAll('input[type="checkbox"]:checked')
        ).map(cb => parseInt(cb.value));

        if (selectedIndices.length === 0) {
            alert("Please select at least one column.");
            return;
        }

        const rows = document.querySelectorAll("#dynamicTable tbody tr");
        const data = [];

        for (let row of rows) {
            const rowData = [];
            let isValid = true;

            selectedIndices.forEach(i => {
                const cell = row.cells[i + 1];
                const value = parseFloat(cell.textContent.trim());
                if (isNaN(value)) isValid = false;
                else rowData.push(value);
            });

            if (isValid) data.push(rowData);
        }

        if (data.length < k) {
            alert("Not enough valid rows to cluster.");
            return;
        }

        const result = simpleKMeans(data, k);
        displayClusterColumn(result);
        resultBox.innerHTML = `<strong>Success:</strong> Clustering done with K = ${k}`;

    });

    clearButton.addEventListener("click", () => {
        resultBox.textContent = "";
        kInput.value = 2;

        const checkboxes = checkboxContainer.querySelectorAll('input[type="checkbox"]');
        checkboxes.forEach(cb => cb.checked = false);

        const headerRow = document.querySelector("#dynamicTable thead tr");
        const bodyRows = document.querySelectorAll("#dynamicTable tbody tr");
        const clusterIndex = Array.from(headerRow.cells).findIndex(cell => cell.textContent === "Cluster");

        if (clusterIndex !== -1) {
            headerRow.deleteCell(clusterIndex);
            bodyRows.forEach(row => row.deleteCell(clusterIndex));
        }
    });

    removeButton.addEventListener("click", () => {
        section.remove();
    });
});

function populateKMeansColumnOptions() {
    const container = document.getElementById("kmeans-feature-checkboxes");
    if (!container) return;

    container.innerHTML = "";
    const headers = document.querySelectorAll("#dynamicTable thead th:not(.row-number)");

    const excluded = ["cluster", "knn prediction", "lr prediction", "logr prediction"];

    headers.forEach((th, index) => {
        const colName = th.textContent.trim().toLowerCase();
        if (excluded.includes(colName)) return;

        const label = document.createElement("label");
        label.style.display = "block";
        label.style.fontFamily = "Open Sans";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = index;

        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(" " + th.textContent));
        container.appendChild(label);
    });
}

const table = document.getElementById("dynamicTable");
if (table) {
    const observer = new MutationObserver(() => {
        const container = document.getElementById("kmeans-feature-checkboxes");
        if (container) populateKMeansColumnOptions();
    });

    observer.observe(table, {
        childList: true,
        subtree: true,
        characterData: true,
        attributes: false
    });
}

function simpleKMeans(data, k, maxIterations = 100) {
    const centroids = [];
    const assignments = new Array(data.length).fill(0);

    while (centroids.length < k) {
        const rand = data[Math.floor(Math.random() * data.length)];
        if (!centroids.some(c => JSON.stringify(c) === JSON.stringify(rand))) {
            centroids.push([...rand]);
        }
    }

    for (let iter = 0; iter < maxIterations; iter++) {
        data.forEach((point, i) => {
            let minDist = Infinity, assigned = 0;
            centroids.forEach((c, idx) => {
                const dist = Math.sqrt(point.reduce((sum, val, d) => sum + (val - c[d]) ** 2, 0));
                if (dist < minDist) {
                    minDist = dist;
                    assigned = idx;
                }
            });
            assignments[i] = assigned;
        });

        const sums = Array.from({ length: k }, () => Array(data[0].length).fill(0));
        const counts = Array(k).fill(0);

        data.forEach((point, i) => {
            const cluster = assignments[i];
            point.forEach((val, d) => sums[cluster][d] += val);
            counts[cluster]++;
        });

        centroids.forEach((c, i) => {
            if (counts[i] > 0) {
                c.forEach((_, d) => c[d] = sums[i][d] / counts[i]);
            }
        });
    }

    return assignments;
}

function displayClusterColumn(assignments) {
    const headerRow = document.querySelector("#dynamicTable thead tr");
    const bodyRows = document.querySelectorAll("#dynamicTable tbody tr");

    const existingIndex = Array.from(headerRow.cells).findIndex(cell => cell.textContent === "Cluster");
    if (existingIndex !== -1) {
        headerRow.deleteCell(existingIndex);
        bodyRows.forEach(row => row.deleteCell(existingIndex));
    }

    const th = document.createElement("th");
    th.textContent = "Cluster";
    th.style.backgroundColor = "#0d8bf1";
    th.style.color = "white";
    headerRow.appendChild(th);

    bodyRows.forEach((row, i) => {
        const td = document.createElement("td");
        td.textContent = assignments[i];
        td.style.color = "black";
        row.appendChild(td);
    });
}

// Logistic Regression section
const logisticOption = document.getElementById("logisticOption");
logisticOption.addEventListener("click", (e) => {
    e.preventDefault();

    const hasData = document.querySelector("#dynamicTable thead th:not(.row-number)");
    if (!hasData) {
        alert("Please import or create a DataFrame first.");
        return;
    }

    const section = document.createElement("div");
    section.className = "stats-section";

    const title = document.createElement("h2");
    title.textContent = "Logistic Regression";

    const featureLabel = document.createElement("label");
    featureLabel.textContent = "Select Features:";
    const featureContainer = document.createElement("div");
    featureContainer.id = "logistic-feature-checkboxes";
    featureContainer.style.maxHeight = "150px";
    featureContainer.style.overflowY = "auto";
    featureContainer.style.border = "1px solid #ccc";
    featureContainer.style.padding = "5px";
    featureContainer.style.marginBottom = "10px";

    const targetLabel = document.createElement("label");
    targetLabel.textContent = "Select Target:";
    const targetSelect = document.createElement("select");
    targetSelect.id = "logistic-target-select";
    targetSelect.style.marginBottom = "15px";

    const resultBox = document.createElement("div");
    resultBox.id = "logistic-results";
    resultBox.className = "results-box";

    const runButton = document.createElement("button");
    runButton.textContent = "Run";
    runButton.style.backgroundColor = "#2196f3";
    runButton.style.color = "white";

    const clearButton = document.createElement("button");
    clearButton.textContent = "Rest";
    clearButton.style.backgroundColor = "red";
    clearButton.style.color = "white";
    clearButton.style.marginLeft = "10px";

    const removeButton = document.createElement("button");
    removeButton.textContent = "Remove";
    removeButton.style.backgroundColor = "red";
    removeButton.className = "remove-button";
    removeButton.style.marginLeft = "10px";

    section.appendChild(title);
    section.appendChild(featureLabel);
    section.appendChild(featureContainer);
    section.appendChild(targetLabel);
    section.appendChild(targetSelect);
    section.appendChild(runButton);
    section.appendChild(clearButton);
    section.appendChild(removeButton);
    section.appendChild(resultBox);

    document.getElementById("stats-sections-container").appendChild(section);

    populateLogisticColumnOptions();

    runButton.addEventListener("click", () => {
        const selectedFeatures = Array.from(
            document.querySelectorAll('#logistic-feature-checkboxes input[type="checkbox"]:checked')
        ).map(cb => parseInt(cb.value));

        const targetIndex = parseInt(targetSelect.value);

        if (selectedFeatures.length === 0) {
            alert("Please select at least one feature.");
            return;
        }

        if (isNaN(targetIndex)) {
            alert("Please select a target column.");
            return;
        }

        const rows = document.querySelectorAll("#dynamicTable tbody tr");
        const X = [], y = [];

        for (let row of rows) {
            const rowData = [];
            let valid = true;

            selectedFeatures.forEach(i => {
                const cell = row.cells[i + 1];
                const val = parseFloat(cell.textContent.trim());
                if (isNaN(val)) valid = false;
                else rowData.push(val);
            });

            const targetVal = row.cells[targetIndex + 1]?.textContent.trim();
            const targetNum = parseInt(targetVal);

            if (valid && (targetNum === 0 || targetNum === 1)) {
                X.push(rowData);
                y.push(targetNum);
            }
        }

        if (X.length === 0) {
            alert("No valid rows to process.");
            return;
        }

        const weights = trainLogisticRegression(X, y);
        const predictions = classify(X, weights);
        displayPredictionColumn(predictions);

        let output = "<strong>Success:</strong> Predictions added to table.";
        resultBox.innerHTML = output;
    });

    clearButton.addEventListener("click", () => {
        resultBox.innerText = "";
        document.querySelectorAll('#logistic-feature-checkboxes input[type="checkbox"]').forEach(cb => cb.checked = false);
        targetSelect.selectedIndex = -1;

        const headerRow = document.querySelector("#dynamicTable thead tr");
        const bodyRows = document.querySelectorAll("#dynamicTable tbody tr");
        const predictionIndex = Array.from(headerRow.cells).findIndex(cell => cell.textContent === "LogR Prediction");

        if (predictionIndex !== -1) {
            headerRow.deleteCell(predictionIndex);
            bodyRows.forEach(row => row.deleteCell(predictionIndex));
        }
    });

    removeButton.addEventListener("click", () => {
        section.remove();
    });
});

const excludedCols = ["cluster", "knn prediction", "lr prediction", "logr prediction"];

function populateLogisticColumnOptions() {
    const headers = document.querySelectorAll("#dynamicTable thead th:not(.row-number)");
    const container = document.getElementById("logistic-feature-checkboxes");
    const targetSelect = document.getElementById("logistic-target-select");

    if (!container || !targetSelect) return;

    container.innerHTML = "";
    targetSelect.innerHTML = "";

    headers.forEach((th, index) => {
        const colName = th.textContent.trim();
        const colLower = colName.toLowerCase();

        if (excludedCols.includes(colLower)) return;

        const label = document.createElement("label");
        label.style.display = "block";
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = index;
        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(" " + colName));
        container.appendChild(label);

        const option = document.createElement("option");
        option.value = index;
        option.text = colName;
        targetSelect.appendChild(option);
    });

    targetSelect.selectedIndex = -1;
}

function displayPredictionColumn(predictions) {
    const headerRow = document.querySelector("#dynamicTable thead tr");
    const bodyRows = document.querySelectorAll("#dynamicTable tbody tr");

    const existingIndex = Array.from(headerRow.cells).findIndex(cell => cell.textContent === "LogR Prediction");
    if (existingIndex !== -1) {
        headerRow.deleteCell(existingIndex);
        bodyRows.forEach(row => row.deleteCell(existingIndex));
    }

    const th = document.createElement("th");
    th.textContent = "LogR Prediction";
    th.style.backgroundColor = "#0d8bf1";
    headerRow.appendChild(th);

    bodyRows.forEach((row, i) => {
        const td = document.createElement("td");
        td.textContent = predictions[i];
        td.style.color = "#black";
        row.appendChild(td);
    });
}

const logisticTable = document.getElementById("dynamicTable");
if (logisticTable) {
    const observer = new MutationObserver(() => {
        const sectionVisible = document.querySelector("#logistic-feature-checkboxes");
        if (sectionVisible) {
            populateLogisticColumnOptions();
        }
    });

    observer.observe(logisticTable, {
        childList: true,
        subtree: true,
        characterData: true
    });
}

// === LOGISTIC REGRESSION CORE ===
function sigmoid(z) {
    return 1 / (1 + Math.exp(-z));
}

function initializeWeights(n) {
    return new Array(n).fill(0);
}

function predict(features, weights) {
    return features.map(row => sigmoid(row.reduce((sum, val, i) => sum + val * weights[i], 0)));
}

function computeLoss(predictions, labels) {
    const n = labels.length;
    let loss = 0;
    for (let i = 0; i < n; i++) {
        const p = predictions[i];
        const y = labels[i];
        loss += -y * Math.log(p + 1e-15) - (1 - y) * Math.log(1 - p + 1e-15);
    }
    return loss / n;
}

function computeGradient(X, y, weights) {
    const n = X.length;
    const m = X[0].length;
    const gradients = new Array(m).fill(0);
    const predictions = predict(X, weights);

    for (let j = 0; j < m; j++) {
        for (let i = 0; i < n; i++) {
            gradients[j] += (predictions[i] - y[i]) * X[i][j];
        }
        gradients[j] /= n;
    }

    return gradients;
}

function trainLogisticRegression(X, y, learningRate = 0.1, epochs = 1000) {
    const weights = initializeWeights(X[0].length);
    for (let epoch = 0; epoch < epochs; epoch++) {
        const gradients = computeGradient(X, y, weights);
        for (let j = 0; j < weights.length; j++) {
            weights[j] -= learningRate * gradients[j];
        }
    }
    return weights;
}

function classify(X, weights, threshold = 0.5) {
    return predict(X, weights).map(p => (p >= threshold ? 1 : 0));
}
    </script>
</body>
</html>